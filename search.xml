<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Algorithms, Part 1]]></title>
    <url>%2F2019%2F03%2F08%2FAlgorithms-Part-1%2F</url>
    <content type="text"><![CDATA[Princeton Algorithm course on coursera. Part 1 Cover: Disjoint set Analysis of Algorithms Stack and Queue Elementary Sorts Mergesort Quicksort Priority Queue Elementary Symbol Tables BST Hash Table Learning Purpose: Being familiar with Java. Having fun with algorithms. Reference Books: Algorithms, 4th Edition Computer Science: An Interdisciplinary Approach Week 1Why study algorithms“Great algorithms are the poetry of computation.” — Francis Sullivan “Algorithms + Data Structures = Programs.” — Niklaus Wirth Union-FindSteps to developing a usable algorithm Model the problem. Find an algorithm to solve it. Fast enough? Fits in memory? If not, figure out why. Find a way to address the problem. Iterate until satisfied. dynamic connectivityGiven a set of N objects. Union command: connect two objects Find/conneted query: is there a path connecting the two objects? Connectivity example Q. Is there a path connecting p and q? Some common understandings: Reflexive: p is connected to p itself. Symmetric: if p is connected to q, then q is connected to p. Transitive: if p is connected to q and q is connected to r, then p is connected to r. Connected components. Maximal set of objects that are mutually connected. e.g. ​ Goal. Design efficient data structure for union-find. Number of objects N can be huge. Number of operations M can be huge. Find queries and union commands may be intermixed. 1234567// APIpublic class UF UF(int N) // initialize union-find data structure with N objects (0 to N-1) void union(int p, int q) // add connection between p and q boolean connected(int p, int q) // are p and q the same component? int find(int p) //component identifier for p (0 to N-1) int count() // number of components quick findData structure Integer array id[] of size N. Interpretation: p and q are connected iff they have the same id. Find: Check if p and q have the same id Union: To merge components containing p and q, change all entries whose id equals id[p] to id[q]. Costly. 12345678910111213141516171819202122public class QuickFindUF&#123; private int[] id; public QuickFindUF(int N) &#123; id = new int[N]; for (int i = 0; i &lt; N; i++) id[i] = i; &#125; public boolean connected(int p, int q) &#123; return id[p] == id[q]; &#125; public void union(int p, int q) &#123; int pid = id[p]; int qid = idp[q]; for (int i = 0; i &lt; id.length; i++) if (id[i] == pid) id[i] = qid; &#125;&#125; algorithm initialize union find quick-find N N 1 N union commands on N object: quadratic time. Much too slow. Quadratic algorithms don’t scale with technology. quick unionData structure Integer array id[] of size N. Interpretation: id[i] is parent of i. Root of i is id[id[id[…id[i]…]]]. Each root represents the connected components. Find: Check if p and q have the same root. Union: To merge components containing p and q, set the id of p’s root to the id of q’s root. (path compression) 12345678910111213141516171819202122232425262728public class QuickUnionUF&#123; private int[] id; public QuickUnionUF(int N) &#123; id = new int[N]; for (int i = 0; i &lt; N; i++) id[i] = i; &#125; private int root(int i) &#123; while (i != id[i]) i = id[i]; return i; &#125; public boolean connected(int p, int q) &#123; return root(p) == root(q); &#125; public void union(int p, int q) &#123; int i = root(p); int j = root(q); id[i] = j; &#125;&#125; Worst case: algorithm initialize union find Quick-union N N N Quick-union defect Trees can get tall Find too expensive (could be N array accesses). improvementsImprovement 1: weighting Weighted quick-union Modify quick-union to avoid tall trees. Keep track of size of each tree (number of objects). Balance by linking root of smaller tree to root of larger tree. Data structure： Same as quick-union, but maintain extra array sz[i] to count number of objects in the tree rooted at i. Find: Identical to quick-union. return root(p) == root(q) Union: Modify quick-union to: Link root of samller tree to root of larger tree. Update the sz[] array. 12345int i = root(p);itn j = root(q);if (i == j) return;if (sz[i] &lt; sz[j]) &#123; id[i] = j; sz[j] += sz[i]; &#125;else &#123; id[j] = i; sz[i] += sz[j]; &#125; Proposition: Depth of any node x is at most $lg N$ algorithm initialize union find Weighted QU N lg N Lg N Improvement 2: path compressionQuick union with path compression: Just after computing the root of p, set the id of each examined node to point to that root. Two-pass implementation: add second loop to root() to set the id[] of each examined node to the root. Simpler one-pass variant: Make every other node in path point to its grandparent (thereby halving path length). 12345678910// variantprivate int root(int i)&#123; while (i != id[i]) &#123; id[i] = id[id[i]] i = id[i] &#125; return i;&#125; Weighted QU + path compression: worst-case time is N + M lg* N (lg * is an iterate function, plz refer to slide for more information) applications Percolation Games (Go, Hex) Dynamic connectivity Least common ancestor Equivalence of finite state automata Hoshen-Kopelman algorithm in physics Hinley-Milner polymorphic type inference Kruskal’s minimum spanning tree algorithm Compiling equivalence statements in Fortran Morphological attribute openings and closings Matlab’s bwlabel() function in image processing Subroutine of many other algorithms Programming Assignment 1Problem: Programming Assignment 1 Code is on my Github page: Percolation Missing the optional task of running time analysis, but I don’t want to do it again because this task is somewhat discouraging for some beginners I think. Analysis of AlgorithmsobservationsAnalytic Engine Reasons to analyze algorithms Predict performance Compare algorithms Provide guarantees Understand theoretical basis Primary practical reason: avoid performance bugs. Discrete Fourier transform N-body simulation Scientific method Observe Hypothesize Predict Verify Validate Principles Experiments must be reproducible Hypotheses must be falsifiable 3-sum problem Standard plot on running time Log-log scale strategy Doubling hypothesis: run program, doubling the size of the input. System independent effects Algorithm Input data System dependent effects Hardware: CPU, memory, cache Software: compiler, interpreter, garbage collector System: operating system, network, other apps mathematical modelsTotal running time: sum of cost * frequency for all operations General concepts 1-sum problem 2-sum problem tilde notation Estimating a discrete sum order-of-growth classification1, log N, N, N lgN, N^2, N^3, 2^N Recurence Easy concepts theory of algorithmsBest case: Lower bound on cost Determined by “easiest” input Provides a goal for all inputs Worst case: Upper bound on cost Determined by “most difficult” input Provides a way to predict performance Average case: Expected cost for random input Need a model for “random” input Provides a way to predict performance Actual data Need to understand input to effectively process it Approach 1: design for the worst case Approach 2: randomize, depend on probailistic guarantee Goals Establish “difficulty” of a problem Develop “optimal” algorithms Approach Suppress details in analyze “to within a constant factor” Eliminate variability in input model by focusing on the worst case Algorithm design approach Start Develop an algorithm Prove a lower bound Gap? Lower the upper bound (discover a new algorithm) Raise the lower bound (more difficult) memoryBit Byte Megabyte (MB) Gigabyte (GB) Old machine: We used to assume a 32-bit machine with 4 byte pointers Modern machine: We now assume a 64-bit machine with 8 byte pointers Typical memory usage for objects in Java Object overhead: 16 bytes Reference: 8 bytes Padding: Each object uses a multiple of 8 bytes Week 2Stacks and Queuesstacksresizing arraysqueuesgenericsiteratorsapplicationsElementary Sortsrules of the gameselection sortinsertion sortshellsortshufflingconvex hullWeek 5Balanced Search Trees2-3 search treesAllow 1 or 2 keys per node 2-node: one key, two children 3-node: two keys, three children Perfect balance: Every path from root to null link has same length Symmetric order: Inorder traversal yields keys in ascending order Search Compare search key against keys in node Find interval containing search key Follow associated link (recursively) Insert into a 2-node at bottom Search for key, as usual Replace 2-node with 3-node Splitting a 4-node is a local transformation: constant number of operations Invariants: Maintain symmetric order and perfect balance Pf: Each transformation maintains symmetric order and perfect balance Tree height: Always $lg N$ red-black BSTsLeft-leaning RB tree Idea: Represent 2-3 tree as a BST Use “internal” left-leaning links as “glue” for 3-nodes A BST such that: No node has two red links connected to it Every path from root to null link has the same number of black links Red links lean left 2-3 tree and RB BST are coresponding as following: Search for red-black BST is the same as the general BST Representation: 12345678910111213141516private static final boolean RED = true;private static final boolean BLACK = false;private class Node&#123; Key key; Value val; Node left, right; boolean color; // color of parent link&#125;private boolean isRed(Node x)&#123; if (x == null) return false; return x.color == RED;&#125; Left rotation: Orient a (temporarily) right-leaning red link to lean left 12345678910private Node rotateLedt(Node h)&#123; assert isRed(h.right); Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; return x;&#125; Invariants: Maintains symmetric order and perfect black balance Right rotation is similar. Color flip: Recolor to split a (temporary) 4-node 123456789private void flipColors(Node h)&#123; assert !isRed(h); assert isRed(h.left); assert isRed(h.right); h.color = RED; h.left.color = Black; h.right.color = Black;&#125; Insertion in a LLRB tree Basic strategy: Maintain 1-1 correspondence with 2-3 trees by applying elementary red-black BST operations Warmup 1: Insert into a tree with exactly 1 node Warmup 2: Insert into a tree with exactly 2 nodes (3 cases) Case 2: Insert into a 3-node at the bottom Do standard BST insert; color new link red Rotate to balance the 4-node (if needed) Flip colors to pass red link up one level Rotate to make lean left (if needed) Repeat case 1 or case 2 up the tree (if needed) Java implementation Reduce one case to another 1234567891011121314private Node put(Node h, Key key, Value val)&#123; if (h == null) return new Node(key, val, RED); int cmp = key.compareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else if (cmp == 0) h.val = val; if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h; if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); return h; &#125; B-trees (Bayer-McCreight, 1972)File system model: Page: Contiguous block of data Probe: First access to a page Property: Time required for a probe is much larger than time to access data within a page Cost model: Number of probes Goal: Access data using minimum number of probes B-tree: Generalize 2-3 trees by allowing up to M-1 key-link pairs per node At least 2 key-link pairs at root At least M/2 key-link pairs in other nodes External nodes contain client keys Internal nodes contain copies of keys to guide search Searching in a B-tree: Start at root Find interval for search key and take corresponding link Search terminates in external node Insertion in a B-tree: Search for new key Insert at bottom Split nodes with M key-link pairs on the way up the tree Red-black trees are widely used as system symbol tables Java: java.util.TreeMap, java.util.TreeSet C++ STL: map, multimap, multiset Linux kernel: completely fair scheduler, linux/rbtree.h Emacs: conservative stack scanning B-tree variants: B+ tree, B* tree, B# tree, … B-trees (and variants) are videly used for file systems and databases Windows: NTFS Mac: HFS, HFS+ Linux: ReiserFS, XFS, Ext3FS, JFS Databases: Oracle, DB2, Ingres, SQL, PostgreSQL Geometric Applications of BSTs1d range searchline segment intersectionkd treesinterval search treesrectangle intersection]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac删除launchpad中无法正常删除的图标]]></title>
    <url>%2F2018%2F11%2F24%2FMac%E5%88%A0%E9%99%A4launchpad%E4%B8%AD%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%88%A0%E9%99%A4%E7%9A%84%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[如何删除launchpad里一些无法正常删除的程序图标 一般launchpad里面应用可以通过两种方式删除： 用访达，在用户家目录的应用程序目录下找到对应的程序，直接删除即可。 直接进launchpad，按住option，点按应用，选择”x”删除即可。 但有些第三方应用无法用这两种方式删除，具体来说，有些应用不会出现在应用程序目录下，但却留在launchpad里面，还删不掉，超级恶心，已经两次碰到过这个问题了，就介绍一下删除这些应用的方法，以防日后的不测。 launchpad这个东西设计比较辣鸡，有很多bug，但总的来说找应用还算方便，但有了Alfrad，就不怎么打开launchpad了。有时候在总可能因为一些奇怪的操作，把一些应用或者文档弄到了launchpad里面，删不掉。出于强迫症，还是想让他变得干干净净的。 第一步，找到com.apple.dock.launchpad文件夹打开访达，按command+shift+G，在地址栏输入/private/var/folders，如下图所示： 然后再folders目录下找到一个名字为com.apple.dock.launchpad的文件夹，我的是在./6l/…/0/目录下。 获取数据库路径在这个文件夹下面继续走，找到名字为db的文件，它就是我们想要修改的数据库，右键这个文件，获取它的路径，如下图所示： 右键-&gt;显示简介 然后把路径复制下来 操作数据库获取数据库路径之后，打开终端，进入到上面的路径，如下图所示： 按照下面的格式输入命令删除第三方应用(或文档)即可1sqlite3 db &quot;delete from apps where title=&apos;应用名称&apos;;&quot;&amp;&amp;killall Dock 然后就可以把这些应用都删掉了 这里有几点要注意一下： 每次删除应用会重启一次dock，屏幕会黑一下，但马上就会好，不用担心。 直接操作数据库比较危险，因此应用名称记得一定要输准确，名字输错(输了一个不存在的应用程序)，可能会把文件夹都展开。 另外再说一点，launchpad还有个bug就是有时候会出现空的文件夹，这些空文件夹也不能用正常手段删除，一个简便可行的方法是把一个应用拖进这个文件夹，然后再拖出来，这个空文件夹就会自动消失。]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记]]></title>
    <url>%2F2018%2F11%2F24%2FJava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考菜鸟教程、实验楼、ZJU翁凯MOOC然后做的一些比较入门级的笔记 javac命令后面跟的是java文件的文件名，例如HelloWorld.java。该命令用于将.java源文件编译为class字节码文件，如：javac HelloWorld.java 运行javac命令后，如果成功编译没有错误的话，会出现一个HelloWorld.class的文件 java后面跟的是java文件中的类名字，例如HelloWorld就是类名，如：java HelloWorld java命令后面不要加.class java分为三个体系： JavaSE：平台标准版 JavaEE：平台企业版 JavaME：平台微型版 java程序员不需要管内存管理，支持类之间的单继承和接口之间的多继承。支持动态绑定 可移植性强，是解释型的，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行，Java平台的解释器对这些字节码进行解释执行，执行中需要的类再联结阶段被载入到运行环境中。 高性能，接近于C++。是多线程的，提供多线程之间的同步机制，关键字synchronized 基础语法对象：对象是类的一个实例，有状态和行为。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。即实例变量是属于对象的。 注意事项： 大小写敏感，Hello和hello是不同的。 类名： 对于所有的类来说，类名的首字母应该大写。如果类由若干单词组成，那么每个单词的首字母应该大写，例如MyFirstClass。 方法名： 所有方法名应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名： 源文件名必须和类名相同。当保存文件的时候，应该使用类名作为文件名保存，文件后缀名必须为.java（如果文件名和类名不同会导致编译错误）。 主方法入口： 所有的java程序由public static void main(String []args)方法开始执行 Java标识符：不能是关键字 修饰符：分两类： 访问控制修饰符：default，public，protected，private 非访问控制修饰符：final，abstract，strictfp 变量：局部变量、类变量（静态变量）、成员变量（非静态变量） 数组：数组是储存在堆上的对象，可以保存多个同类型变量。 枚举：enum FreshJuiceSize{SMALL, MEDIUM, LARGE} 用.访问运算符访问枚举成员 利用继承的方法可以重用已存在的类的属性和方法，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass） 接口：可以理解为对象间相互通信的协议。接口在继承中很重要 接口只定义派生要用到的方法，方法的具体实现还是取决于派生类 支持的面向对象特性：多态，继承，封装，抽象，类，对象，实例，方法，重载 一个类可以包含局部变量（在方法，构造方法或者语句块中定义的变量，方法结束后自动销毁），成员变量（定义在类中，方法体之外，在创建对象的时候实例化，成员变量可以被类中的方法、构造方法和特定类的语句块访问）类变量（声明在类中，方法体之外，必须声明为static类型） 构造方法：每个类都有构造方法，如果没有显式指定，Java编译器会为该类提供一个默认构造方法。在创建对象时，至少要调用一个构造方法，构造方法的名称必须与类同名，一个类可以有多个构造方法（可以在一个构造方法里滴啊用另一个构造方法） 创建对象：三步： 声明：声明一个对象，包括对象名称和对象类型 实例化：用关键字new创建一个对象 初始化：使用new创建对象时，会调用构造方法初始化对象 访问实例变量可以用.运算符或者调用类中的方法 源文件声明规则一个源文件只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。 如果一个类定义在某个包中，那么package应该在源文件首行 如果源文件有import语句，应该放在package语句和类定义之前。如果没有package语句，那么import语句应该在源文件中最前面。import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 包：包主要用来对类和接口分类 import语句提供一个合理路径，使得编译器可以找到某个类 Java数据类型两大数据类型：内置数据类型和引用数据类型 八种基本类型 byte类型8位，主要用来替代int char类型是一个单一的16位Unicode字符，最小\u0000(即0)，最大值是\uffff(即65535) 引用类型： 类似于指针，指向一个对象，指向对象的变量是引用变量，在声明时被指定为一个特定类型。默认值null boolean类型不支持类型转换 强制类型转换，自动类型转换 Java变量类型在Java语言中，所有变量在使用前必须声明。 Java支持的变量类型有： 类变量：独立于方法之外的变量，用static修饰 实例变量：独立于方法之外的变量，没有static修饰 局部变量：类的方法中的变量 Java局部变量局部变量声明再方法、构造方法或者语句块中。 局部变量在方法、构造方法或者语句块被执行时候创建，当它们执行完后，变量会自动销毁。 访问修饰符不能用于修饰局部变量。 局部变量只在声明它的方法、构造方法或语句块中可见。 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，它的作用域就限制在这个方法中。 Java实例变量实例变量声明在一个类中，但在方法、构造方法和语句块之外。 当一个对象被实例化之后，每个实例变量的值就跟着被确定。 实例变量在对象被创建的时候创建，在对象被销毁的时候销毁。 实例变量的值至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。 实例变量可以声明在使用前或者使用后，这是因为在创建对象的时候总是会先去初始化那些实例变量。 访问修饰符可以修饰实例变量。 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有，是封装的基本理念。可以通过访问修饰符使实例变量对子类可见。 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。 在静态方法或者其他类中要访问实例变量需要用完全限定名。 Java类变量类变量也称为静态变量，在类中用static关键字声明，但必须在构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。也可以在静态语句块中初始化。 静态变量通过ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。 Java修饰符Java语言的修饰符主要分为： 1、访问修饰符 2、非访问修饰符 Java支持4种不同的访问权限 default（缺省）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private：在同一类内可见。使用对象：变量、方法。不能修饰类 public：对所有类可见。使用对象：类、接口、变量、方法 protected：对同一包内的类和所有子类可见。使用对象：变量、方法。不能修饰类 final方法：final方法可以被子类继承，但是不能被子类修改。 声明final方法的主要目的是防止该方法的内容被修改。 final类：不能被继承 abstract：抽象类，类似于接口类，声明抽象类的唯一目的是将来对该类进行扩充。抽象方法，是一种没有任何实现的方法，该方法的实现由子类提供。抽象方法不能被声明为final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类，这个就类似于C++中的纯虚函数了。也即抽象类中的抽象方法在抽象类中只需要提供声明，不需要提供实现，而需要在继承它的子类中实现对应的抽象方法。 synchronized修饰符： 这个关键字声明的方法同一时间只能被一个线程访问。 Java运算符大的可以分为：算术运算符，关系运算符，位运算符，逻辑运算符，赋值运算符，其他运算符。 ?:条件运算符，三元运算符。其他没什么好说的 instanceof运算符：用于操作对象实例，检查对象是否是一个特定类型（类类型或接口类型） 循环控制只说新出现的： Java增强for循环： Java5引入了一种主要用于数组的增强型for循环。 格式如下： for(声明语句:表达式) { //代码句子 } 声明语句：声明新的局部变量，变量类型必须和数组元素的类型匹配。作用域限定在循环语句块。 表达式：要访问的数组名，或者返回值为数组的方法。 break关键字： 主要用在循环语句或者switch语句中，用来跳出整个语句块。 continue关键字： 不说了 包裹类型：封包和解包以Character为例 Character：是char的包裹类型，处理char型对象，方法有： 1、isLetter()：判断是否是一个字母 2、isDigit()：判断是否是一个数字字符 3、isWhitespace()：判断是否是一个空格 4、isUpperCase()：判断是否是大写字母 5、isLowerCase()：判断是否是小写字母 6、toUpperCase()：指定字母的大写形式 7、toLowerCase()：指定字母的小写形式 8、toString()：返回字符的字符串形式，字符串的长度仅为1 Java String类在Java中字符串属于对象，Java提供了String类来创建和操作字符串 创建字符串： 1String greeting = "cainiao"; 在代码中遇到字符串常量时，编译器会使用该值创建一个String对象，可以使用关键字和构造方法来创建String对象。 String类不可修改 用于获取有关对象的信息的方法称为访问器方法。 String类的一个访问器方法是length()方法，返回字符串对象包含的字符数 12String site = "www.runoob.com";int len = site.length(); 连接字符串： 1string1.concat(string2); 返回string2连接string1的新字符串。也可以对字符串常量使用concat()方法。如： 1"我的名字是".concat("Runoob"); 更常用的是用’+’运算符来连接字符串： 1"Hello," + " runoob" + "!"; 创建格式化字符串： 使用静态方法format()可以生成格式化字符串 12String fs;fs = String.format("sdfasdfasdf"); //因为是静态方法，直接用类名调用即可 String方法： 1、chaAt():返回指定索引处的char值 2、compateTo():把这个字符串和另一个对象或者字符串比较，按字典序 3、concat():连接字符串 4、equals():将此字符串与指定的对象比较 5、length():返回此字符串的长度 6、toLowerCase():小写化 7、toUpperCase():大写化 8、trim():返回字符串的副本，忽略前导空白和尾部空白 其实java这些类很多方法和python十分类似，学习成本不高 StringBuffer和StringBuilder类当对字符串进行修改的时候，需要使用StringBuffer和StringBuilder类 和String类不同，StringBuffer和StringBuilder类的对象能被多次修改，并且不产生新的未使用对象 StringBuilder不是线程安全的，不能同步访问，但是StringBuilder相较于StringBuffer有速度优势，所以多数情况下建议使用StringBuilder类。但在应用程序要求线程安全的情况下，必须使用StringBuilder类。这个类的方法如下： Append：将指定的字符串追加到此字符序列 reverse：将此字符串序列用反转形式取代 delete：移除此序列的字符串中的字符，原型为public delete(int start, int end) Insert：将int参数的字符串表示形式插入序列中，原型为public insert(int offset, in i) replace：用String字符串替换此序列的子字符串中的字符，原型为replace(int start, int end, String str) Capacity：返回当前容量 charAt：获取此序列指定索引处的char值 indexOf：返回第一次出现的指定字符串在该字符串中的索引，有两种重构，indexOf(str)和indexOf(String str, int fromIndex)。第一种从头开始找，第二种从指定索引出开始找，返回第一次出现的指定子字符串在该字符串中的索引 length：返回长度 toString：返回序列中数据的字符串表示形式 Java数组Java语言提供的数组是用来存储固定大小的同类型元素 声明数组变量： 12dataType[] arrayRefVar; //首选方法dataType arrayReVar[] //效果相同，但不是首选 后面一种风格是C/C++风格，Java程序员建议使用第一种风格 创建数组： 1arrayReVar = new dataType[arraySize]; 上面语法语句做了两件事： 用dataType[arraySize]创建了一个数组 把新创建的数组的引用赋值给变量arrayReVar（Java对象变量是引用） 当然数组声明和创建可以用一条语句来完成： 1dataType[] arrayReVar = new dataType[arraySize]; 也可以直接初始化： 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 数组的元素是通过引用访问的。索引从0开始，一直到arrayRefVar.length-1 处理数组： 通常使用基本循环或者foreach循环（也成为增强型for循环，之前提到过，也能从目录直接导引过去，是从JDK 1.5开始引进的） 增强型for循环的优点在于可以不使用下标的情况下遍历数组 12345678910public class TestArray&#123; public static void main(String[] args)&#123; double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; //打印所有元素 for(double element:myList)&#123; System.out.println(element); &#125; &#125;&#125; 输出结果为： 12341.92.93.43.5 数组作为函数参数（传引用）： 123456789public static void printArray(int[] array)&#123; for(int i = 0; i &lt; array.length; i++)&#123; System.out.print(array[i] + " "); &#125;&#125;//调用printArray(new int[]&#123;3, 1, 2, 6, 4, 2&#125;); 数组作为函数返回值： 12345678public static int[] reverse(int[] list)&#123; int[] result = new int[list.length]; for(int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) result[j] = list[i]; return result;&#125;//result数组作为函数的返回值 多维数组（数组的数组）： 12345678String str[][] = new String[3][4]; //二维数组是一个特殊的一维数组，每一个元素都是一维数组//分配空间type arrayName = new type[arraylength1][arraylength2];int a[][] = new int[2][3];//引用num[1][0]; Arrays类java.util.Arrays类能方便操作数组，它提供的方法都是静态的 功能有： 给数组赋值：通过fill方法 对数组排序：通过sort方法，按升序 比较数组：通过equals方法比较数组中元素值是否相等 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作 函数原型： 1234public static int binarySearch(Object[] a, Object key);public static boolean equals(long[] a, long[] a2);public static void fill(int[] a, int val);public static void sort(Object[] a); 日期和时间Java.util包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象。 第一个构造函数使用当前日期和时间来初始化对象： 12Date()Date(long millisec) Date对象的方法： after：若调用此方法的对象在指定日期之前返回true，否则返回false。 before：和上面的反一下 clone：返回此对象的副本 compareTo：比较当前调用此方法的Date对象和指定日期。相等则返回0。 equals：子类重载，判断调用此方法的Date对象和指定日期是否相等，相等则返回true，否则返回false。 getTime：返回1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数 hashCode：返回此对象的哈希码值 setTime：用自1970年1月1日00:00:00 GMT以来time毫秒数来设置时间和日期 toString：把此Date对象转换为下面格式的String：dow mon dd hh:mm:ss zzz yyyy 其中dow是一周中的某一天(Sun, Mon, Tue, Wed, Thu, Fri, Sat) 日期比较： 1、使用getTime方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值 2、使用方法before(), after()和equals()。 3、使用compareTo方法，它是由comparable接口定义的，Date类实现了这个接口 SimpleDateFormat格式化日期： 这是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许用户选择任何自定义日期时间格式来运行。 这个还挺好用的 格式化转换需要格式，在创建对象的时候指定格式 休眠： Sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用，不是让当前线程独自占用CPU资源，以留时间给其他线程执行的机会。 Calendar类： 设置和获取日期数据的特定部分： 是一个抽象类，在实际使用时实现特定的子类的对象，方法是使用getInstance方法 12Calendar c = Calendar.getInstance(); //默认是当前日期c.set(2009, 6, -1, 12); 正则表达式正则表达式定义了字符串的模式 可以用来搜索、编辑或处理文本 正则表达式不仅限于某一种语言 java.util.regex类包括下面的类： Pattern类：pattern对象是一个正则表达式的编译表示。Pattern类没有公用构造方法。要创建Pattern对象，必须首先调用公用静态编译方法，返回一个Pattern对象，该方法接受一个正则表达式作为它的第一个参数 Matcher类：对输入字符串进行解释和匹配操作的引擎。和Pattern类一样，Matcher没有公用构造，需要调用Pattern对象的matcher方法来获取一个Matcher对象 PatternSystaxException：非强制异常类，表示一个正则表达式模式中的语法错误 这部分和所有其他的正则表达式一样，特别复杂，等待学习 Java方法System.out.println() println()是一个方法 System是系统类 out是标准输出对象 方法是语句的集合，在一起执行一个功能 方法命名规则：第一个单词以小写字母作为开头，后面的单词用大写字母开头写，不用连接符。如：addPerson 123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 方法包含一个方法头和一个方法体。方法的所有部分包括： 修饰符：可选，告诉编译器如何调用该方法。定义了该方法的访问类型 返回值类型：方法可能有返回值 方法名：方法的实际名称。方法名和参数表共同构成方法签名 参数类型：参数像一个占位符。方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数可选，方法可以无参 方法体：方法体包含具体的语句，定义该方法的功能 方法调用：根据方法是否返回值来选择 值传递参数：和引用传递不同，对象变量存的是对象引用，也正是因为有引用，才支持了Java的垃圾回收机制 变量作用域： 变量作用域是程序中该变量可以被引用的部分 方法内定义的变量称为局部变量 局部变量的作用域从声明开始，直到包含它的块结束 局部变量必须声明后才可以使用 方法参数范围涵盖整个方法。参数实际上是一个局部变量 for循环的初始化部分声明的变量，其作用范围在整个循环 循环体内声明的变量其适用范围是从它声明到循环体结束。 所以在for里面int i可以省内存 命令行参数：如果希望运行一个程序的时候再传递给它消息，就要靠命令行参数给main函数实现。 构造方法：当一个对象被创建的时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值（可以有参数列表） 通常用构造方法给一个类的实例变量赋初值，或者执行其他步骤来创建一个完整对象。 不定义也有默认构造方法，它把所有成员初始化为0 可变参数typeName… parameterName 在方法声明中，在指定参数类型后加一个省略号(…)。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通参数必须在它之前声明。 finalize()方法： 类似于析构函数，它在对象呗垃圾收集器析构（回收）之前被调用，这个方法叫做finalize()，它用来清除回收对象。 例如，可以使用finalize来确保一个对象打开的文件夹被关闭了。 在finalize()方法里，用户需要制定对象被销毁时要执行的操作 1234protected void finalize()&#123; //source code&#125; 关键字protected是一个限定符，它确保finalize方法不会被该类外的代码调用 Java的垃圾回收可以由JVM自动完成，如果选择手动回收垃圾，就可以用上面的方法 System.gc()：显式调用Java垃圾收集器 Java流(Stream)、文件(File)和IOJava.io包几乎包含了所有操作输入、输出需要的类。流类代表了输入源和输出目标 Java.io包中的流支持很多格式，比如：基本类型、对象、本地化字符集等 一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据 Java为I/O提供了强大的灵活的支持，使得其广泛应用于文件IO和网络编程中 读取控制台输入： Java控制台输入由System.in完成 获得一个绑定到控制台的字符流： 1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedReader对象创建后，可以用read()方法从控制台读取一个字符，或者用readLine()方法读取一个字符串 每次调用read方法，它从输入流读取一个字符并把该字符作为整数值返回。流结束的时候返回-1。 从控制台读取字符串： 从标准输入读取一个字符串需要使用BufferedReader的readLine方法 它的一般格式是： 1String readLine() throws IOException JDK 5以后的版本也可以使用Java Scanner类来获取控制台输入，也是更简单的方法 控制台输出; print和println：这些方法都由类PrintStream定义，System.out是该类对象的一个引用 PrintStream实现write的最简单格式为： 1void write(int byteval) 下面演示使用write输出字符”A”和换行符： 12345678910import java.io.*public class WriteDemo&#123; public static void main(String args[])&#123; int b; b = 'A'; System.out.write(b); System.out.write('\n'); &#125;&#125; 注意write方法不经常使用，因为print和println方法用起来更方便 读写文件： 流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据 文件输入输出流： FileInputStream: 该流用于从文件读取数据，它的对象可以用关键字new来创建 可以使用字符串类型的文件名来创建一个输入流对象来读取文件： 1InputStream f = new FileInputStream("C:/java/hello"); 也可以用一个文件对象来创建一个输入流对象来读取文件，首先要用File()方法来创建一个文件对象： 12File f = new File("C:/java/hello");InputStream out new FileInputStream(f); 创建文件输入流之后，就可以使用下面的方法来操作流了： Close：关闭文件输入流并释放与此流有关的所有系统资源。抛出IOException异常 finalize：清除与该文件的连接。确保在不再引用文件输入流时调用其close方法。抛出IOException异常 read：从InputStream对象读取指定字节数据。返回整数值，表示下一字节数据。结尾则返回-1 read重载：read(byte[] r) 从输入流读取r.length长度的字节。返回读取的字节数，文件结尾则返回-1 available：不受阻塞地读流 FileOutputStream： 该流在打开文件进行输出前，如果目标文件不存在，那么该流会创建该文件 123OutputStream f = new FileOutputStream("C:/hava/hello");File f = new File("C:/java/hello");OutputStream f = new FileOutputStream(f); 流操作： Close：关闭此文件输出流并释放与此流有关的所有系统资源。抛出IOException异常 finalize：清除与该文件的连接，确保不再引用文件输入流时调用其close方法。抛出IOException异常 write：把指定字节写到输出流中 write(byte[] w)：重载，把指定数组中w.length长度的字节写到OutputStream中 在读写的时候注意一下数据编码即可，不要出现乱码 创建目录： File类中有两个方法创建文件夹： mkdir()方法创建一个文件夹，成功则返回true，失败则返回false。 mkdirs()方法创建一个文件夹和它的所有父文件夹 读取目录： 创建一个File对象并且如果它是一个目录，那么调用isDirectory方法会返回true 可以调用该对象上的list方法，来提取它包含的文件和文件夹列表 删除目录： 可以使用java.io.File.delete方法 需要保证该目录下没有其他文件才能正确删除，否则删除失败 可以用上面的这些类和方法来实现展示目录结构、递归删除目录的功能 1234567891011121314151617181920212223//一级展开目录:/tmpimport java.io.*;public class main&#123; //data public static void main(String[] args)&#123; String dirname = "/tmp"; File f1 = new File(dirname); if(f1.isDirectory())&#123; System.out.println("Directory: " + dirname); String[] s1 = f1.list(); for(String s:s1)&#123; File f = new File(dirname + "/" + s); if(f.isDirectory()) System.out.println(s + " is a directory!"); else System.out.println(s + " is a file!"); &#125; &#125; else System.out.println(dirname + " is not a directory!"); &#125;&#125; Java Scanner类java.util.Scanner是Java5之后出现的新特性，可以直接通过Scanner类来获取用户的输入，而不用前面那些复杂的IO类（前面那些IO类主要是为了了解和学习） 1Scanner s = new Scanner(System.in); Scanner类的next和nextLine方法可以获取输入字符串，在读取之前需要使用hasNext和hasNextLine来判断是否还有输入的数据 next方法的核心代码： 1234if(scan.hasNext())&#123; System str1 = scan.next(); System.out.println("输入的数据为: " + str1);&#125; nextLine方法的核心代码基本类似 next和nextLine的区别： next(): 一定要读取到有效字符后才可以结束输入 对输入有效字符之前遇到的空白，next方法会自动将其去掉 只有输入有效字符后才能将后面输入的空白作为分隔符或者结束符 next不能得到带有空格的字符串 nextLine(): 以Enter为结束符，也就是说nextLine方法返回的是输入回车之前的所有字符 可以获得空白 如果要读入int或float类型的数据，在Scanner类中也有对应支持，输入之前可以用hasNextXxx()方法检测数据类型，判断用户的输入char是否可以转换为小数或者整数格式 Java 异常处理异常指的是程序中的一些错误，并不是所有错误都是异常，错误有时候是可以避免的。 异常引发的原因有多种，通常包含： 用户输入了非法数据 要打开的文件不存在 网络通信时连接中断，或者JVM内存溢出 程序员需要掌握三种类型异常： 检查性异常：用户错误或问题引起的异常，是程序员无法预见的，比如打开一个不存在的文件 运行时异常：运行异常是可能被程序员避免的异常。运行时异常可以在编译时被忽略 错误：错误不是异常，而是脱离程序员控制的问题。比如当栈溢出时，一个错误就发生了，它们在编译时是检查不到的。 Exception类： 所有异常都是从java.lang.Exception类继承的子类 捕获异常可以用try catch代码块： 12345try&#123; //程序代码&#125;catch(ExceptionName e1)&#123; //catch块&#125; 多重捕获： 1234567try&#123; //程序代码&#125;catch(ExceptionName1)&#123; &#125;catch(ExceptionName2)&#123; &#125; 当try中的保护代码块发生一个异常时，try后面的catch块就会检查是不是要捕获的异常，如果异常发生在catch块，异常会传递到该catch块 throws/throw关键字： 如果一个方法没有捕获到一个检查性异常，那么该方法使用throws关键字来声明异常，然后在方法实现体里面用throw抛出异常 finally关键字用在创建try代码块后面执行的代码块，无论是否发生异常，finally代码块中的代码总是被执行，在finally代码块中，可以运行清理类型等收尾善后性质的语句。格式如下： 123456789try&#123; //程序代码&#125;catch(异常类型1 异常变量名1)&#123; //程序代码&#125;catch(异常类型2 异常变量名2)&#123; //程序代码&#125;finally&#123; //程序代码&#125; 其他关于异常没有什么好说的，日常写很少用到，用到再查就可以了 Java面向对象Java继承允许创建分等级层次的类 类的继承格式： 1234567class 父类&#123; &#125;class 子类 extends 父类&#123; &#125; 继承用来解决代码重复的问题 1234567891011121314151617public class Animal&#123; private String name; //动物的名字 private int id; //动物身份标签 public Animal(String myName, int myid)&#123; name = myName; id = myid; &#125; public void eat()&#123; System.out.println(name + "正在吃"); &#125; public void sleep()&#123; System.out.println(name + "正在睡"); &#125; public void introduction()&#123; System.out.println("大家好！我是" + id + "号" + name + "."); &#125;&#125; 这个animal类可以作为其他动物类的父类 12345678910111213//企鹅类public class Penguin extends Animal&#123; public Penguin(String myName, int myid)&#123; super(myName, myid); //调用父类构造函数 &#125;&#125;//老鼠类public class Mouse extends Animal&#123; public Mouse(String myName, int myid)&#123; super(myName, myid); &#125;&#125; 继承的特性： 子类拥有父类非private属性，方法（）实际上子类也有父类的private属性和方法，只不过被隐藏了 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法，这个称为重载 Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是祖宗关系 提高了类之间的耦合性（这个是继承带来的坏处，耦合度高会造成代码间联系太过紧密，代码独立性差） 继承可以用extends和implements这两个关键字来实现，且所有类都是继承于java.lang.Object，这个Object是所有类的祖宗，当一个类没有继承关键字，则默认继承Object，这个特性在C++里面是没有的 1234567891011121314//extendspublic class Animal&#123; private String name; private int id; public Animal(Stirng myName, String myid)&#123; //初始化属性值 &#125; public void eat()&#123;&#125; public void sleep()&#123;&#125;&#125;public class Penguin extends Animal&#123; &#125; implements关键字主要用来实现接口，可以同时继承多个接口： 1234567891011public interface A&#123; public void eat(); public void sleep();&#125;public interface B&#123; public void show();&#125;public class C implements A, B&#123;&#125; super和this关键字： super关键字可以通过这个来实现对父类成员的访问，用来引用当前对象的父类 this关键字：指向自己的引用 12345678910111213141516171819202122232425class Animal&#123; public void eat()&#123; System.out.println("animal : eat"); &#125;&#125;class Dog extends Animal&#123; //overload public void eat&#123;&#125;&#123; System.out.println("dog : eat"); &#125; public void eatTest()&#123; this.eat(); //this自调用 super.eat(); //调用父类方法 &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Animal a = new Animal(); a.eat(); //父类吃 Dog d = new Dog(); d.eatTest(); //调用子类吃和父类吃 &#125;&#125; final关键字： 可以把类定义为不能继承的，即是最终类；或者用于修饰方法，表示该方法不能被子类重写，主要用作保护 12final class 类名&#123;&#125;修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;&#125; 构造器： 子类不继承父类的构造器，只是调用。如果父类的构造器带有参数，必须在子类的构造器中显式通过super关键字调用父类的构造器并给出参数。 如果父类是默认构造器，那么在子类构造器中可以不用管父类构造 Java重写(Override)与重载(Overload)重写(Override)： 重写是子类对父类允许访问的方法的实现过程进行重新编写，返回值和形参都不变。重写的好处是子类可以个性化定制属于自己的方法。 12345678910111213141516171819202122class Animal&#123; public void move()&#123; System.out.println("动物可以移动"); &#125;&#125;class Dog extends Animal&#123; public void move()&#123; System.out.println("狗可以跑和走"); &#125;&#125;public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); //Animal对象 Animal b = new Dog(); //Dog对象 a.move(); //执行Animal类的方法 b.move(); //执行Dog类的方法 &#125;&#125; 方法的重写规则： 参数列表必须完全和被重写的方法相同 返回类型必须完全与被重写的方法的返回值类型相同 访问权限不能比父类中被重写的方法的访问权限更低。一般都是一样的权限，这一点倒是很少会注意到，既然有这么一条就写着吧 父类的成员方法只能被它的子类重写 声明为final的方法不能被重写，因为final是保护方法和类的 声明为static的方法不能被重写，因为static的是属于类的 子类和父类在同一个包中，则子类可以重写父类的所有方法，除了声明为private和final的方法。private的话子类也不能访问，final本身提供了保护 子类和父类不在同一个包中，则相比上一条，子类不能重写父类的friendly方法了，因为friendly表示同包访问权限 构造方法不能重写 如果不能继承，就不重写 重载(Overload)： 重载是在同一个类中，方法名字相同而参数不同，返回值类型可以相同可以不同 每个重载的方法（或构造函数）都必须有一个独一无二的参数型列表 最常见的重载是构造函数的重载 重载规则: 被重载的方法必须改变参数列表（参数个数或类型不同） 被重载的方法可以改变返回值类型 被重载的方法可以改变访问修饰符 方法可以在同一个类中或者在一个子类中被重载 无法以返回值作为重载函数的区分标准 方法的重写和重载是Java多态性的不同表现 Java多态多态是同一个行为具有多个不同表现形式或形态的能力 多态是一个接口，使用不同的实例而执行不同操作 多态的优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件： 继承 重写 父类引用指向子类对象 虚方法子类可以重写父类的方法，当子类调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法，被重写的方法是可以动态绑定的，如果像调用父类中被重写的方法，则必须使用关键字super 多态的实现方式： 重写overwtire 接口interface 抽象类和抽象方法 Java抽象类在面向对象中，所有的对象都是通过类来描绘的，但不是所有类都是用来描绘对象的，如果一个类没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量，成员方法和构造方法的访问方式和普通类一样 抽象类不能实例化对象，所以抽象类必须被继承，才能使用 通过abstract来定义抽象类： 123456789101112131415161718192021222324252627282930313233public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number)&#123; System.out.println("Constructing an Employee"); this.name = name; this.address = address; this.number = number; &#125; public double computePay()&#123; System.out.println("Inside Employee computePay"); return 0.0; &#125; public void mailCheck()&#123; System.out.println("Mailing a check to " + this.name + " " + this.address); &#125; public String toString()&#123; return name + " " + address + " " + number; &#125; public String getName()&#123; return name; &#125; public String getAddress()&#123; return address; &#125; public void setAddress(String newAddress)&#123; address = newAddress; &#125; public int getNumber()&#123; return number; &#125;&#125; 抽象方法： 如果该方法的具体实现可以由它的子类确定，那么可以在父类中声明该方法为抽象方法 Abstract关键字可以用来声明抽象方法，抽象方法只包含一个方法名，没有方法体 1234567public abstract class Employee&#123; private String name; private String address; private int number; public abstract double computePay();&#125; 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类 任何子类必须重写父类的抽象方法，或者声明自身为抽象类 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。实现后才能实例化对象 Java封装Encapsulation是一种将抽象是函式接口的实现细节部分包装、隐藏起来的方法。 封装被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 封装的优点 良好的封装能减少耦合 类内部的结构可以自由修改 可以对成员变量进行更精确的控制 隐藏信息，实现细节 实现封装的步骤： 修改属性的可见性： 1234public class Person&#123; private String name; private int age;&#125; 将name和age属性设置为私有，只能本类才能访问，其他类访问不了，这样就实现了对信息的隐藏 Java接口Interface，在Java语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个雷通过继承接口的方式，从而来继承接口的抽象方法。接口不是类，编写接口的方式和类很相似，但它们属于不同概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内描述的所有方法，否则就必须声明为抽象类。另外，Java中接口类型可用来声明一个变量，他们可以成为一个空指针，或者绑定一个以此接口实现的对象。 接口与类的相似点： 一个接口可以有多个方法 接口文件保存在.java结尾的文件中，文件名使用接口名 接口的字节码文件保存在.class结尾的文件中 接口相应的字节码文件必须在于包名称相匹配的目录结构中 接口与类的区别： 接口不能用于实例化对象 接口没有构造方法 接口中所有方法必须是抽象方法 接口中所有方法必须是抽象方法 接口不能包含成员变量，除了static和final变量 接口不是被类继承了，而是要被类实现 接口支持多继承 接口特性： 接口中每一个方法也是隐式抽象的，接口中的方法会被隐式指定为public abstract 接口中可以含有变量，但是接口中的变量会被隐式指定为public static final变量 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法 抽象类和接口的区别： 抽象类中的方法可以有方法体，但是接口中的方法不行 抽象类中的成员变量可以是多种类型的，而接口类中的变量只能是public static final类型的 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法 一个类只能继承一个抽象类，而一个类却可以实现多个接口 接口声明： 1234interface 接口名称 [extends 其他的接口名]&#123; //声明变量 //声明抽象方法&#125; 接口隐式抽象，当声明一个接口的时候，不必使用abstract关键字 接口中每个方法也是隐式抽象的，声明不需要abstract关键字 接口中的方法都是公有的 1234interface Animal&#123; public void eat(); public void travel();&#125; 接口的实现： 当类实现接口的时候，需要实现接口中的所有方法，否则，类必须声明为抽象的类。 类使用implements关键字实现接口。类声明中，implements关键字放在class声明后面 实现一个接口的语法： 1...implements 接口名称 实现接口方法的时候记住要保持一致的方法名，和相同或兼容的返回值类型 如果实现接口的类是抽象类，那么就没有必要实现接口的方法 一个接口可以继承另一个接口，和类之间的继承方式比较相似。接口的继承用extends关键字，子接口继承父接口的方法 Java包Package 为了更好地组织类，Java提供了包机制，用于区别类名的命名空间 包的作用： 把功能相似或相关的接口组织在同一个包中，方便类的查找和使用 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字可以相同，当调用不同包中相同类名的类时，应该加上包名加以区分 包限定了访问权限，拥有包访问权限的类才能访问某个包中的类 Java使用包这种机制是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注释等 包语法： 1package pkg; 包声明应该放在第一行 import关键字：导入包 1import pkg; Java高级主题Java数据结构 枚举（Enumeration） 位集合（BitSet） 向量（Vector） 栈（Stack） 字典（Dictionary） 哈希表（Hashtable） 属性（Properties） 上面的数据结构是传统遗留的，在Java2中引入了一种新的框架-集合框架（Collection） 枚举（Enumeration）枚举接口虽然本身不属于任何数据结构，但它在其他数据勾结的范畴里应用很广。枚举接口定义了一种从数据结构取回连续元素的方式。 枚举定义了一个叫nextElement的方法，该方法用来得到一个包含多个元素的数据结构的下一个元素。 123456789101112131415161718192021import java.util.Vector;import java.util.Enumeration; public class EnumerationTester &#123; public static void main(String args[]) &#123; Enumeration&lt;String&gt; days; Vector&lt;String&gt; dayNames = new Vector&lt;String&gt;(); dayNames.add("Sunday"); dayNames.add("Monday"); dayNames.add("Tuesday"); dayNames.add("Wednesday"); dayNames.add("Thursday"); dayNames.add("Friday"); dayNames.add("Saturday"); days = dayNames.elements(); while (days.hasMoreElements())&#123; System.out.println(days.nextElement()); &#125; &#125;&#125; 位集合（BitSet）位集合实现了一组可以单独设置和清除的位或标志 该类在处理一组布尔值的时候非常有用 向量（Vector）向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态变化。 和数组一样，Vector对象的元素也能通过索引访问。 使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态变化。 Vector类实现了一个动态数组，和ArrayList类似，但是两者是不同的： Vector是同步访问的 Vector包含了许多传统方法，这些方法不属于集合框架 Vector主要用在事先不知道数组的大小，或者只需要一个可以改变大小的数组的情况 Vector类支持四种构造方法： 1234Vector();Vector(int size);Vector(int size, int incr);Vector(Collection c); 除了从父类继承的方法外Vector还定义了以下方法： add：在向量的指定位置插入指定的元素，add(int index, Object element) add：提供了末尾添加的重载方法，add(Object element) capacity：返回此向量当前的容量 clear：从向量中移除所有元素 clone：返回向量的一个副本 contains：如果此向量包含指定的元素，则返回true equals：比较指定对象与此对象的相等性 get：返回向量中指定位置的元素，参数为索引值 indexOf：返回此向量中第一次出现的指定元素的索引，从index处正向搜索，如果未找到该元素，则返回-1 lastIndexOf：返回向量中最后一次出现指定元素的索引，如果未找到则返回-1 isEmpty：判断是否为空 firstElement：返回向量的第一个组件 lastElement：返回向量的最后一个组件 remove：移除指定位置的元素 size：和capacity不同，返回的是现在向量中的组件数 toString：返回此向量的字符串表示形式，其中包含每个元素的String表示形式 elements：返回此向量组件的枚举，可以直接赋值给枚举变量 remove:两类重载，接受index参数或者Object参数，移除指定位置的元素或者移除指定元素的第一个匹配项 removeAll：移除所有指定元素，接受Collection参数 toArray：返回一个数组 toString：返回一个字符串 栈（Stack）栈（Stack）实现了一个后进先出（LIFO）的数据结构 可以把栈理解为垂直分布的栈，当添加一个元素时，就将新元素放在其他元素的顶部 当从栈中取出元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。 是Vector一个子类，Stack定义了默认构造用来创建空栈 empty:测试堆栈是否为空 peek:查看栈顶对象并不移除 pop:移除栈顶对象并返回 push:把项压入堆栈顶部 search:返回对象在栈中的位置，以1位基数 字典（Dictionary）字典（Dictionary）类是一个抽象类，它定义了键值映射到值的数据结构 当想要通过特定的键而不是整数索引来访问数据的时候，应该使用Dictionary 由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现 和Map类相似。 element:返回值的枚举 get:返回指定键对应的值 isEmpty:测试字典是否为空 keys:返回键的枚举 remove:接受key参数，从字典中移除指定key put:put(Object key, Object value),将指定key映射到该字典中指定的value size:返回条目的数量 Dictionary类已经过时了，在实际的开发中，常常使用Map 哈希表（Hashtable）Hashtable类提供了一种在用户键结构的基础上来组织数据的手段 Hashtable现已经集成到集合框架中。和HashMap类似，但是支持同步 构造方法： Hashable() Hashtable(int size) //创建指定大小的哈希表 Hashtable(int size, float fillRatio) //创建指定大小的哈希表，并根据fillRate填充 Hashtable(Map m) //以m中元素为初始化元素的哈希表 Hashtable除了实现Map接口中定义的方法之外，还自定义了其他的方法 clear: 清空哈希表，使其不包含任何键值 contains: 给的参数是值，测试是否存在对应的键 isEmpty: 判断哈希表是否为空 size: 返回键的数量 toString: 返回Hashtable的字符串形式 属性（Properties）Properties继承于Hashtable.Properties类表示一个持久的属性集，水星列表中每个键及其对应值都是一个字符串 Properties类被许多Java类使用。 集合框架Java的集合框架主要包括两种类型的容器，一种是集合(Collection)，存储一个元素集合，另一种是图(Map),存储键值映射。Collection接口有三种子类型：List, Set和Queue，再下面是抽象类，再下面是具体实现类，常用的有ArrayList, LinkedList, HashSet, LinkedHashset。集合框架提供了一套性能优良，使用方便的接口和类。Java集合框架位于java.util包里，所以使用集合框架的时候需要导包。 集合接口 Collection接口：是最基本的集合接口，一个Collection代表一组Object，存储一组不唯一，无序的对象 List接口：是一个有序的Collection，支持0索引。存储不唯一，有序的对象 Set接口：与Collection一样，只是不允许重复 SortedSet接口：继承于Set保存有序集合 Map接口：存储键值对，提供key到value的映射 SortedMap：继承于Map，使Map保证升序排列 Set和List相比，Set无序不重复，List有序可以重复 Set访问效率低，删除和插入效率高 List和数组类似，可以动态增长。其实现类有ArrayList，LinkedList，Vector 使用迭代器进行遍历： 1234Iterator&lt;String&gt; ite = list.iterator();while(ite.hasNext())&#123; System.out.println(ite.next());&#125; 把链表变成相关容器再遍历： 12345String strArray = new String[list.size()];list.toArray(strArray);for(int i=0;i&lt;strArray.length;i++)&#123; System.out.println(strArray[i]);&#125; Java泛型generics。和C++泛型差不多，具体要用可以再查，平时练习是用不到的。 泛型方法：方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型。编译器适当地处理每个方法的调用 泛型类：在类名后面加上类型参数声明部分 类型通配符：1public static void getData(List&lt;?&gt; data)&#123;&#125; 差不多就完结了，后面一些比如序列化，网络编程之类的，平常也用不到，只有特定的开发场景中才可能会用到。另外Java Mooc笔记没有上传，因为没有全部看完。]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F11%2F24%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式是一种文本模式，包括普通字符和特殊字符(也称为元字符)。正则表达式使用单个字符来描述、匹配一系列匹配某个句法规则的字符串。 在练Codewars的时候，意识到了正则表达式的重要性，尤其是在字符串处理方面。另外正则表达式在Linux文件操作上也比较重要。 之前多多少少接触过一点，但是也意识到了他的复杂性。如果说shell编程那一套是鬼画符，那么这个应该也是差不多的。 但是正则表达式在某些情况下真的特别好用(听说学会正则表达式还能提升成就感)，于是就下定决心入这个坑了。 简介?通配符匹配文件名中的0个或1个字符，而*通配符匹配0个或多个字符。相比于通配符，正则表达式功能更强大，而且更加灵活。实例： 1^[0-9]+abc$ 说明： ^匹配输入字符串的开始位置 [0-9]+匹配多个数字，[0-9]匹配单个，+匹配一个或多个 abc$匹配字母abc并以abc结尾，$表示输入字符串的结束位置 为什么要用正则表达式？ 测试字符串内的模式。称为数据验证 替换文本。使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本来替换他 基于模式匹配从字符串中提取子字符串 发展历史： 可以追溯到对人类神经系统如何工作的早期研究，科学家提出数学的方式描述神经网络。后来有科学家发表神经网络方面的文章正式提出了正则表达式的概念。 应用领域： 目前，正则表达式在众多软件中得到广泛应用，包括*nix(Linux, Unix等)、HP操作系统、PHP、C#、Java开发环境 语法正则表达式描述了一种字符串匹配的模式(pattern)，可以用来检查一个串中是否含有某种子串、将匹配的子串替换或者从某个串中提取出符合某个条件的子串等。 正则表达式的组件可以是单个字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合 普通字符： 没有显式指定为元字符的所有可打印和不可打印字符。包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符： \cx: 匹配由x指明的控制字符 \f: 匹配一个换页符，等价于\x0c和\cL \n: 匹配一个换行符，等价于\x0a和\cJ \r: 匹配匹配一个回车符，等价于\x0d和\cM \s: 匹配任何空白字符，包括空格、制表符、换页符等等 \S: 匹配任何非空白字符 \t: 匹配一个制表符，等价于\x09和\cl \v: 匹配一个垂直制表符，等价于\x0b和\cK 特殊字符： 如果要匹配特殊字符，要进行转义 $: 匹配输入字符串的结尾位置 (): 标记一个子表达式的开始和结束位置 *: 匹配前面的子表达式零次或多次 +: 匹配前面的子表达式一次或多次 .: 匹配除换行符之外的任何单字符 [: 标记一个中括号表达式的开始 ?: 匹配前面的子表达式零次或一次 \: 将下一个字符标记为特殊字符 ^: 匹配输入表达式的开始位置 {: 标记限定表达式的开始 |: 指明两项之间的一个选择 限定符： 指定正则表达式的一个给定组件必须出现多少次才能满足匹配 *: 匹配前面的子表达式零次或多次 +: 匹配前面的子表达式一次或多次 ?: 匹配前面的子表达式零次或一次 {n}: n是一个非负整数，匹配确定的n次。例如’o{2}’用来匹配两个o {n,}: n是一个非负整数，至少匹配n次，例如’o{2,}’用来匹配两个或多个o {n,m}: m和n均为非负整数，最少匹配n次且最多匹配m次，例如’o{1,3}’匹配1-3个o 实例： 以章节号为例： 12345678//任何位数的章节标题/chapter [1-9][0-9]*///匹配0-99章/chapter [0-9]&#123;1,2&#125;///匹配1-99章/chapter [1-9][0-9]?/ 定位符： 定位符能够将正则表达式固定到行首或行尾，定位符用来描述字符串或单词的边界 ^: 匹配输入字符串开始的位置 $: 匹配输入字符串结尾的位置 \b: 匹配一个单词边界，即字与空格间的位置 B: 非单词边界匹配 限定符和定位符不能一起用 选择： 用圆括号将所有选择项括起来 反向引用： 不太明白 元字符 \: 将下一个字符标记为特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符 ^: 匹配输入字符串的开始位置 $: 匹配输入字符串的结束位置 *: 匹配前面的子表达式零次或多次 +: 匹配前面的子表达式一次或多次 ?: 匹配前面的子表达式零次或一次 {n}: n是一个非负整数，匹配确定的n次 {n,}: n是一个非负整数，至少匹配n次 {n,m}: 至少匹配n次，最多m次 .: 匹配换行符\n \r之外的任何单个字符 (pattern): 匹配pattern并获取这一匹配 (?:pattern): 非获取匹配 (?=pattern): 正向匹配预查 (?!pattern): 正向否定预查 (?&lt;=pattern): 反向肯定预查 (?&lt;!pattern): 反向否定预查 x|y: 匹配x或y [xyz]: 字符集合，匹配所包含的任意一个字符 [^xyz]: 负值字符集合，匹配未包含的任意单个字符 [a-z]: 字符范围，匹配指定范围内的任意字符 [^a-z]: 负值字符范围，匹配任何不在指定范围内的任意字符 \b: 匹配一个单词边界，也就是单词和空格间的位置 \B: 匹配非单词边界 \cx: 匹配由x指明的控制字符 \d: 匹配一个数字字符，等价于[0-9] \D: 匹配一个非数字字符，等价于[^0-9] \f: 匹配一个换页符 \n: 匹配一个换行符 \r: 匹配一个回车符 \s: 匹配任何空白字符，包括空白、制表符、换页符等 \S: 匹配任何非空白字符 \t: 匹配一个制表符 \v: 匹配一个垂直制表符 \w: 匹配字母、数字、下划线。等价于[A-Za-z0-9_] \W: 匹配非字母、数字、下划线。等价于[^A-Za-z0-9_] \xn: 匹配n，其中n为十六进制转义值 \num: 匹配num，其中num是一个正整数 \nm: 标志一个八进制转义值或向后引用 \un: 匹配n，n是一个用四个十六进制数字表示的Unicode字符 运算符优先级从左到右计算，并遵循运算符优先级 优先级由高到低： \: 转义符 (),(?:),(?=),[]: 圆括号和方括号 *,+,?,{n},{n,},{n,m}: 限定符 ^,$,\,任何元字符，任何字符: 定位点和序列 |: 替换 匹配规则基本模式匹配 模式是正则表达式最基本的元素，是一组描述字符串特征的字符。 1^once 这个模式包含^，表示字符串开头，用来匹配那些以once为开头的字符串 1bucket$ 这个模式包含$，表示字符串结尾，用来匹配以bucket为结尾的字符串 1^bucket$ 表示只匹配bucket 字符簇： 1[AaEeIiOoUu] 确定重复出现： {x}的意思是前面的字符或字符簇只出现x次，{x,}的意思是前面的内容出现x或更多的次数，{x,y}表示前面的内容至少出现x次，至多出现y次。特殊字符*和{0,}是等价的，+和{1,}是等价的。 示例简单表达式： 1/a7M/ 匹配a7M 字符匹配： 12/a.7//filename\.txt/ 中括号表达式： 创建匹配字符组的一个列表 12/Chapter [12345]//Chapter [1-5]/ 中括号表达式的典型应用是指定任何大写或小写字母或数字匹配： 1/[A-Za-z0-9]/ 实验楼正则表达式基础grep, expr, sed, awk或vi中会经常用到正则表达式 正则表达式的特殊符号： [:alnum:]: 代表英文大小写字母和数字 [:alpha:]: 代表英文大小写字母 [:blank:]: 代表空格和tab键 [:cntrl:]: 代表键盘上的控制按键，如CR,LF,TAB,DEL [:digit:]: 代表数字 [:graph:]: 代表空白字符以外的其他 [:lower:]: 代表小写字母 [:print:]: 代表可以被打印出来的任何字符 [:punct:]: 代表标点符号 [:upper:]: 代表大写字母 [:space:]: 代表会产生空白的字符如空格，tab，CR等 [:xdigt:]: 代表十六进制数字类型 在使用正则表达式时需要留意语系，不同语系同一模式匹配结果可能有差异 通过grep命令使用正则表达式grep参数 -a: 将binary档案以text档案的形式搜索 -c: 计算找到“搜索字符串”的次数 -i: 忽略大小写，所以大小写视为相同 -n: 顺便输出行号 -v: 反向选择，即输出不包含搜索字符串的内容 []中包含的字符，只能是一个，-用来表示字符范围，[^…]排除型字符组，跟反向选择是一样的。例如： [abc]: 表示a或b或c [0-9]: 表示0-9中任意一个数字，等价于0123456789 [^a1&lt;]: 表示除a，1，&lt;外的任意一个字符 [^a-z]: 表示除小写字母外的任意一个字符 行首行尾控制，例如： ^[A-Z]: 表示以大写字母开头 $[A-Z]: 表示以大写字母结尾 重复次数控制： {}可以用来限定字符重复出现的次数 {n}: 表示只匹配n次 {n,}: 表示至少匹配n次 {n,m}: 表示至少匹配n次，至多匹配m次 通过sed命令使用正则表达式sed是非交互式编辑器。它不会修改文件。sed编辑器逐行处理文件，并将结果发送到屏幕。处理过程为：把当前正在处理的行保存到一个临时缓冲区中（也称为模式空间），然后处理临时缓冲区中的行，完成后发送到屏幕上，sed每处理好一行就把它从临时缓冲区中删除，然后读入下一行，进行处理和显示。处理完最后一行后，sed就结束运行。 1nl regular_express.txt | sed '2,5d' 2,5表示2到5行，d表示删除 1nl regular_express.txt | sed '2,$d' 删除2到最后一行 1sed -i '1d' regular_express 在源文件中删除第一行 扩展正则表达式知识点:egrep命令 可以使用grep -E 来使用扩展正则表达式，效果和egrep相同 挑战 找到登录shell为bash的用户: 1grep -n 'bash' user 找到UID或GID是5位数或以上的用户行记录 1grep -n '[0-9]\&#123;5,\&#125;' user 有主目录在/var/spo??l下的用户，但想不起来spo后面到底有几个o，找出满足条件的用户行记录 1grep -n '/var/spo\+l' user 已知有个用户其用户名形如 ‘mi..M’，中间有未知多个mi，找出该用户的用户行记录 1grep -n '[mi]\+M' user 至于输出到文件，简单重定向就完事了]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
</search>
