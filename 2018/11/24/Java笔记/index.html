<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="参考菜鸟教程、实验楼、ZJU翁凯MOOC然后做的一些比较入门级的笔记">
<meta name="keywords" content="Programming">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记">
<meta property="og:url" content="http://yoursite.com/2018/11/24/Java笔记/index.html">
<meta property="og:site_name" content="Qingliu">
<meta property="og:description" content="参考菜鸟教程、实验楼、ZJU翁凯MOOC然后做的一些比较入门级的笔记">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-03-08T20:14:20.954Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java笔记">
<meta name="twitter:description" content="参考菜鸟教程、实验楼、ZJU翁凯MOOC然后做的一些比较入门级的笔记">






  <link rel="canonical" href="http://yoursite.com/2018/11/24/Java笔记/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java笔记 | Qingliu</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

<a href="https://github.com/Aden-Q" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Qingliu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/24/Java笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qingliu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qingliu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-24 18:46:57" itemprop="dateCreated datePublished" datetime="2018-11-24T18:46:57-06:00">2018-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-08 14:14:20" itemprop="dateModified" datetime="2019-03-08T14:14:20-06:00">2019-03-08</time>
              
            
          </span>

          

          
            
          

          
          
             <span id="/2018/11/24/Java笔记/" class="leancloud_visitors" data-flag-title="Java笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Heat: </span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考菜鸟教程、实验楼、ZJU翁凯MOOC然后做的一些比较入门级的笔记</p>
<a id="more"></a>
<p>javac命令后面跟的是java文件的文件名，例如HelloWorld.java。该命令用于将.java源文件编译为class字节码文件，如：javac HelloWorld.java</p>
<p>运行javac命令后，如果成功编译没有错误的话，会出现一个HelloWorld.class的文件</p>
<p>java后面跟的是java文件中的类名字，例如HelloWorld就是类名，如：java HelloWorld</p>
<p>java命令后面不要加.class</p>
<p>java分为三个体系：</p>
<p>JavaSE：平台标准版</p>
<p>JavaEE：平台企业版</p>
<p>JavaME：平台微型版</p>
<p>java程序员不需要管内存管理，支持类之间的单继承和接口之间的多继承。支持动态绑定</p>
<p>可移植性强，是解释型的，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行，Java平台的解释器对这些字节码进行解释执行，执行中需要的类再联结阶段被载入到运行环境中。</p>
<p>高性能，接近于C++。是多线程的，提供多线程之间的同步机制，关键字synchronized</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>对象：对象是类的一个实例，有状态和行为。</p>
<p>类：类是一个模板，它描述一类对象的行为和状态。</p>
<p>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</p>
<p>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。即实例变量是属于对象的。</p>
<p>注意事项：</p>
<p>大小写敏感，Hello和hello是不同的。</p>
<p>类名：</p>
<p>对于所有的类来说，类名的首字母应该大写。如果类由若干单词组成，那么每个单词的首字母应该大写，例如MyFirstClass。</p>
<p>方法名：</p>
<p>所有方法名应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</p>
<p>源文件名：</p>
<p>源文件名必须和类名相同。当保存文件的时候，应该使用类名作为文件名保存，文件后缀名必须为.java（如果文件名和类名不同会导致编译错误）。</p>
<p>主方法入口：</p>
<p>所有的java程序由public static void main(String []args)方法开始执行</p>
<p>Java标识符：不能是关键字</p>
<p>修饰符：分两类：</p>
<p>访问控制修饰符：default，public，protected，private</p>
<p>非访问控制修饰符：final，abstract，strictfp</p>
<p>变量：局部变量、类变量（静态变量）、成员变量（非静态变量）</p>
<p>数组：数组是储存在堆上的对象，可以保存多个同类型变量。</p>
<p>枚举：enum FreshJuiceSize{SMALL, MEDIUM, LARGE}</p>
<p>用.访问运算符访问枚举成员</p>
<p>利用继承的方法可以重用已存在的类的属性和方法，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）</p>
<p>接口：可以理解为对象间相互通信的协议。接口在继承中很重要</p>
<p>接口只定义派生要用到的方法，方法的具体实现还是取决于派生类</p>
<p>支持的面向对象特性：多态，继承，封装，抽象，类，对象，实例，方法，重载</p>
<p>一个类可以包含局部变量（在方法，构造方法或者语句块中定义的变量，方法结束后自动销毁），成员变量（定义在类中，方法体之外，在创建对象的时候实例化，成员变量可以被类中的方法、构造方法和特定类的语句块访问）类变量（声明在类中，方法体之外，必须声明为static类型）</p>
<p>构造方法：每个类都有构造方法，如果没有显式指定，Java编译器会为该类提供一个默认构造方法。在创建对象时，至少要调用一个构造方法，构造方法的名称必须与类同名，一个类可以有多个构造方法（可以在一个构造方法里滴啊用另一个构造方法）</p>
<p>创建对象：三步：</p>
<p>声明：声明一个对象，包括对象名称和对象类型</p>
<p>实例化：用关键字new创建一个对象</p>
<p>初始化：使用new创建对象时，会调用构造方法初始化对象</p>
<p>访问实例变量可以用.运算符或者调用类中的方法</p>
<h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>一个源文件只能有一个public类</p>
<p>一个源文件可以有多个非public类</p>
<p>源文件的名称应该和public类的类名保持一致。</p>
<p>如果一个类定义在某个包中，那么package应该在源文件首行</p>
<p>如果源文件有import语句，应该放在package语句和类定义之前。如果没有package语句，那么import语句应该在源文件中最前面。import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p>
<p>包：包主要用来对类和接口分类</p>
<p>import语句提供一个合理路径，使得编译器可以找到某个类</p>
<h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p>两大数据类型：内置数据类型和引用数据类型</p>
<p>八种基本类型</p>
<p>byte类型8位，主要用来替代int</p>
<p>char类型是一个单一的16位Unicode字符，最小\u0000(即0)，最大值是\uffff(即65535)</p>
<p>引用类型：</p>
<p>类似于指针，指向一个对象，指向对象的变量是引用变量，在声明时被指定为一个特定类型。默认值null</p>
<p>boolean类型不支持类型转换</p>
<p>强制类型转换，自动类型转换</p>
<h3 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h3><p>在Java语言中，所有变量在使用前必须声明。</p>
<p>Java支持的变量类型有：</p>
<p>类变量：独立于方法之外的变量，用static修饰</p>
<p>实例变量：独立于方法之外的变量，没有static修饰</p>
<p>局部变量：类的方法中的变量</p>
<h4 id="Java局部变量"><a href="#Java局部变量" class="headerlink" title="Java局部变量"></a>Java局部变量</h4><p>局部变量声明再方法、构造方法或者语句块中。</p>
<p>局部变量在方法、构造方法或者语句块被执行时候创建，当它们执行完后，变量会自动销毁。</p>
<p><strong>访问修饰符不能用于修饰局部变量。</strong></p>
<p>局部变量只在声明它的方法、构造方法或语句块中可见。</p>
<p>局部变量是在栈上分配的。</p>
<p>局部变量没有默认值，所以局部变量被声明后，它的作用域就限制在这个方法中。</p>
<h4 id="Java实例变量"><a href="#Java实例变量" class="headerlink" title="Java实例变量"></a>Java实例变量</h4><p>实例变量声明在一个类中，但在方法、构造方法和语句块之外。</p>
<p>当一个对象被实例化之后，每个实例变量的值就跟着被确定。</p>
<p>实例变量在对象被创建的时候创建，在对象被销毁的时候销毁。</p>
<p>实例变量的值至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</p>
<p>实例变量可以声明在使用前或者使用后，这是因为在创建对象的时候总是会先去初始化那些实例变量。</p>
<p>访问修饰符可以修饰实例变量。</p>
<p>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有，是封装的基本理念。可以通过访问修饰符使实例变量对子类可见。</p>
<p>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。</p>
<p>在静态方法或者其他类中要访问实例变量需要用完全限定名。</p>
<h4 id="Java类变量"><a href="#Java类变量" class="headerlink" title="Java类变量"></a>Java类变量</h4><p>类变量也称为静态变量，在类中用static关键字声明，但必须在构造方法和语句块之外。</p>
<p>无论一个类创建了多少个对象，类只拥有类变量一份拷贝。</p>
<p>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</p>
<p>静态变量储存在静态存储区。<strong>经常被声明为常量，很少单独使用static声明变量。</strong></p>
<p>静态变量在第一次被访问时创建，在程序结束时销毁。</p>
<p>与实例变量具有相似的可见性。但为了对类的使用者可见，<strong>大多数静态变量声明为public类型。</strong></p>
<p>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。也可以在静态语句块中初始化。</p>
<p>静态变量通过ClassName.VariableName的方式访问。</p>
<p>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。</p>
<h3 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h3><p>Java语言的修饰符主要分为：</p>
<p>1、访问修饰符</p>
<p>2、非访问修饰符</p>
<p>Java支持4种不同的访问权限</p>
<p>default（缺省）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>
<p>private：在同一类内可见。使用对象：变量、方法。不能修饰类</p>
<p>public：对所有类可见。使用对象：类、接口、变量、方法</p>
<p>protected：对同一包内的类和所有子类可见。使用对象：变量、方法。不能修饰类</p>
<p>final方法：final方法可以被子类继承，但是不能被子类修改。</p>
<p>声明final方法的主要目的是防止该方法的内容被修改。</p>
<p>final类：不能被继承</p>
<p>abstract：抽象类，类似于接口类，声明抽象类的唯一目的是将来对该类进行扩充。抽象方法，是一种没有任何实现的方法，该方法的实现由子类提供。抽象方法不能被声明为final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类，这个就类似于C++中的纯虚函数了。也即抽象类中的抽象方法在抽象类中只需要提供声明，不需要提供实现，而需要在继承它的子类中实现对应的抽象方法。</p>
<p>synchronized修饰符：</p>
<p>这个关键字声明的方法同一时间只能被一个线程访问。</p>
<h3 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h3><p>大的可以分为：算术运算符，关系运算符，位运算符，逻辑运算符，赋值运算符，其他运算符。</p>
<p>?:条件运算符，三元运算符。其他没什么好说的</p>
<p>instanceof运算符：用于操作对象实例，检查对象是否是一个特定类型（类类型或接口类型）</p>
<h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p>只说新出现的：</p>
<p>Java增强for循环：</p>
<p>Java5引入了一种主要用于数组的增强型for循环。</p>
<p>格式如下：</p>
<p>for(声明语句:表达式)</p>
<p>{</p>
<pre><code>//代码句子
</code></pre><p>}</p>
<p>声明语句：声明新的局部变量，变量类型必须和数组元素的类型匹配。作用域限定在循环语句块。</p>
<p>表达式：要访问的数组名，或者返回值为数组的方法。</p>
<p>break关键字：</p>
<p>主要用在循环语句或者switch语句中，用来跳出整个语句块。</p>
<p>continue关键字：</p>
<p>不说了</p>
<h3 id="包裹类型：封包和解包"><a href="#包裹类型：封包和解包" class="headerlink" title="包裹类型：封包和解包"></a>包裹类型：封包和解包</h3><p>以Character为例</p>
<p>Character：是char的包裹类型，处理char型对象，方法有：</p>
<p>1、isLetter()：判断是否是一个字母</p>
<p>2、isDigit()：判断是否是一个数字字符</p>
<p>3、isWhitespace()：判断是否是一个空格</p>
<p>4、isUpperCase()：判断是否是大写字母</p>
<p>5、isLowerCase()：判断是否是小写字母</p>
<p>6、toUpperCase()：指定字母的大写形式</p>
<p>7、toLowerCase()：指定字母的小写形式</p>
<p>8、toString()：返回字符的字符串形式，字符串的长度仅为1</p>
<h3 id="Java-String类"><a href="#Java-String类" class="headerlink" title="Java String类"></a>Java String类</h3><p>在Java中字符串属于对象，Java提供了String类来创建和操作字符串</p>
<p>创建字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">"cainiao"</span>;</span><br></pre></td></tr></table></figure>
<p>在代码中遇到字符串常量时，编译器会使用该值创建一个String对象，可以使用关键字和构造方法来创建String对象。</p>
<p>String类不可修改</p>
<p>用于获取有关对象的信息的方法称为<strong>访问器方法</strong>。</p>
<p>String类的一个访问器方法是length()方法，返回字符串对象包含的字符数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String site = <span class="string">"www.runoob.com"</span>;</span><br><span class="line"><span class="keyword">int</span> len = site.length();</span><br></pre></td></tr></table></figure>
<p>连接字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string1.concat(string2);</span><br></pre></td></tr></table></figure>
<p>返回string2连接string1的新字符串。也可以对字符串常量使用concat()方法。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"我的名字是"</span>.concat(<span class="string">"Runoob"</span>);</span><br></pre></td></tr></table></figure>
<p>更常用的是用’+’运算符来连接字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello,"</span> + <span class="string">" runoob"</span> + <span class="string">"!"</span>;</span><br></pre></td></tr></table></figure>
<p>创建格式化字符串：</p>
<p>使用静态方法format()可以生成格式化字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String fs;</span><br><span class="line">fs = String.format(<span class="string">"sdfasdfasdf"</span>);	<span class="comment">//因为是静态方法，直接用类名调用即可</span></span><br></pre></td></tr></table></figure>
<p>String方法：</p>
<p>1、chaAt():返回指定索引处的char值</p>
<p>2、compateTo():把这个字符串和另一个对象或者字符串比较，按字典序</p>
<p>3、concat():连接字符串</p>
<p>4、equals():将此字符串与指定的对象比较</p>
<p>5、length():返回此字符串的长度</p>
<p>6、toLowerCase():小写化</p>
<p>7、toUpperCase():大写化</p>
<p>8、trim():返回字符串的副本，忽略前导空白和尾部空白</p>
<p>其实java这些类很多方法和python十分类似，学习成本不高</p>
<h3 id="StringBuffer和StringBuilder类"><a href="#StringBuffer和StringBuilder类" class="headerlink" title="StringBuffer和StringBuilder类"></a>StringBuffer和StringBuilder类</h3><p>当对字符串进行修改的时候，需要使用StringBuffer和StringBuilder类</p>
<p>和String类不同，StringBuffer和StringBuilder类的对象能被多次修改，并且不产生新的未使用对象</p>
<p>StringBuilder不是线程安全的，不能同步访问，但是StringBuilder相较于StringBuffer有速度优势，所以多数情况下建议使用StringBuilder类。但在应用程序要求线程安全的情况下，必须使用StringBuilder类。这个类的方法如下：</p>
<p>Append：将指定的字符串追加到此字符序列</p>
<p>reverse：将此字符串序列用反转形式取代</p>
<p>delete：移除此序列的字符串中的字符，原型为public delete(int start, int end)</p>
<p>Insert：将int参数的字符串表示形式插入序列中，原型为public insert(int offset, in i)</p>
<p>replace：用String字符串替换此序列的子字符串中的字符，原型为replace(int start, int end, String str)</p>
<p>Capacity：返回当前容量</p>
<p>charAt：获取此序列指定索引处的char值</p>
<p>indexOf：返回第一次出现的指定字符串在该字符串中的索引，有两种重构，indexOf(str)和indexOf(String str, int fromIndex)。第一种从头开始找，第二种从指定索引出开始找，返回第一次出现的指定子字符串在该字符串中的索引</p>
<p>length：返回长度</p>
<p>toString：返回序列中数据的字符串表示形式</p>
<h3 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h3><p>Java语言提供的数组是用来存储固定大小的同类型元素</p>
<p>声明数组变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;		<span class="comment">//首选方法</span></span><br><span class="line">dataType arrayReVar[]		<span class="comment">//效果相同，但不是首选</span></span><br></pre></td></tr></table></figure>
<p>后面一种风格是C/C++风格，Java程序员建议使用第一种风格</p>
<p>创建数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayReVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure>
<p>上面语法语句做了两件事：</p>
<ol>
<li>用dataType[arraySize]创建了一个数组</li>
<li>把新创建的<strong>数组的引用</strong>赋值给变量arrayReVar（Java对象变量是引用）</li>
</ol>
<p>当然数组声明和创建可以用一条语句来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayReVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure>
<p>也可以直接初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure>
<p>数组的元素是通过引用访问的。索引从0开始，一直到arrayRefVar.length-1</p>
<p>处理数组：</p>
<p>通常使用基本循环或者foreach循环（也成为增强型for循环，之前提到过，也能从目录直接导引过去，是从JDK 1.5开始引进的）</p>
<p>增强型for循环的优点在于可以不使用下标的情况下遍历数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.4</span>, <span class="number">3.5</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印所有元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> element:myList)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.9</span></span><br><span class="line"><span class="number">2.9</span></span><br><span class="line"><span class="number">3.4</span></span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure>
<p>数组作为函数参数（传引用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">printArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>数组作为函数返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] list)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[list.length];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = result.length - <span class="number">1</span>; i &lt; list.length; i++, j--)</span><br><span class="line">        result[j] = list[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result数组作为函数的返回值</span></span><br></pre></td></tr></table></figure>
<p>多维数组（数组的数组）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str[][] = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">4</span>];		<span class="comment">//二维数组是一个特殊的一维数组，每一个元素都是一维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分配空间</span></span><br><span class="line">type arrayName = <span class="keyword">new</span> type[arraylength1][arraylength2];</span><br><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用</span></span><br><span class="line">num[<span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>java.util.Arrays类能方便操作数组，它提供的方法都是静态的</p>
<p>功能有：</p>
<ul>
<li>给数组赋值：通过fill方法</li>
<li>对数组排序：通过sort方法，按升序</li>
<li>比较数组：通过equals方法比较数组中元素值是否相等</li>
<li>查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作</li>
</ul>
<p>函数原型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Object[] a, Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span>[] a2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>Java.util包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象。</p>
<p>第一个构造函数使用当前日期和时间来初始化对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date()</span><br><span class="line">Date(<span class="keyword">long</span> millisec)</span><br></pre></td></tr></table></figure>
<p>Date对象的方法：</p>
<p>after：若调用此方法的对象在指定日期之前返回true，否则返回false。</p>
<p>before：和上面的反一下</p>
<p>clone：返回此对象的副本</p>
<p>compareTo：比较当前调用此方法的Date对象和指定日期。相等则返回0。</p>
<p>equals：子类重载，判断调用此方法的Date对象和指定日期是否相等，相等则返回true，否则返回false。</p>
<p>getTime：返回1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数</p>
<p>hashCode：返回此对象的哈希码值</p>
<p>setTime：用自1970年1月1日00:00:00 GMT以来time毫秒数来设置时间和日期</p>
<p>toString：把此Date对象转换为下面格式的String：dow mon dd hh:mm:ss zzz yyyy</p>
<p>其中dow是一周中的某一天(Sun, Mon, Tue, Wed, Thu, Fri, Sat)</p>
<p>日期比较：</p>
<p>1、使用getTime方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值</p>
<p>2、使用方法before(), after()和equals()。</p>
<p>3、使用compareTo方法，它是由comparable接口定义的，Date类实现了这个接口</p>
<p><strong>SimpleDateFormat</strong>格式化日期：</p>
<p>这是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许用户选择任何自定义日期时间格式来运行。</p>
<p>这个还挺好用的</p>
<p>格式化转换需要格式，在创建对象的时候指定格式</p>
<p>休眠：</p>
<p>Sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用，不是让当前线程独自占用CPU资源，以留时间给其他线程执行的机会。</p>
<p>Calendar类：</p>
<p>设置和获取日期数据的特定部分：</p>
<p>是一个抽象类，在实际使用时实现特定的子类的对象，方法是使用getInstance方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();	<span class="comment">//默认是当前日期</span></span><br><span class="line">c.set(<span class="number">2009</span>, <span class="number">6</span>, -<span class="number">1</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式定义了字符串的模式</p>
<p>可以用来搜索、编辑或处理文本</p>
<p>正则表达式不仅限于某一种语言</p>
<p>java.util.regex类包括下面的类：</p>
<ul>
<li>Pattern类：pattern对象是一个正则表达式的编译表示。Pattern类没有公用构造方法。要创建Pattern对象，必须首先调用公用静态编译方法，返回一个Pattern对象，该方法接受一个正则表达式作为它的第一个参数</li>
<li>Matcher类：对输入字符串进行解释和匹配操作的引擎。和Pattern类一样，Matcher没有公用构造，需要调用Pattern对象的matcher方法来获取一个Matcher对象</li>
<li>PatternSystaxException：非强制异常类，表示一个正则表达式模式中的语法错误</li>
</ul>
<p>这部分和所有其他的正则表达式一样，特别复杂，等待学习</p>
<h3 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h3><p>System.out.println()</p>
<p>println()是一个方法</p>
<p>System是系统类</p>
<p>out是标准输出对象</p>
<p>方法是语句的集合，在一起执行一个功能</p>
<p>方法命名规则：第一个单词以小写字母作为开头，后面的单词用大写字母开头写，不用连接符。如：addPerson</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法包含一个方法头和一个方法体。方法的所有部分包括：</p>
<ul>
<li>修饰符：可选，告诉编译器如何调用该方法。定义了该方法的访问类型</li>
<li>返回值类型：方法可能有返回值</li>
<li>方法名：方法的实际名称。方法名和参数表共同构成方法签名</li>
<li>参数类型：参数像一个占位符。方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数可选，方法可以无参</li>
<li>方法体：方法体包含具体的语句，定义该方法的功能</li>
</ul>
<p>方法调用：根据方法是否返回值来选择</p>
<p>值传递参数：和引用传递不同，对象变量存的是对象引用，也正是因为有引用，才支持了Java的垃圾回收机制</p>
<p>变量作用域：</p>
<p>变量作用域是程序中该变量可以被引用的部分</p>
<p>方法内定义的变量称为局部变量</p>
<p>局部变量的作用域从声明开始，直到包含它的块结束</p>
<p>局部变量必须声明后才可以使用</p>
<p>方法参数范围涵盖整个方法。参数实际上是一个局部变量</p>
<p>for循环的初始化部分声明的变量，其作用范围在整个循环</p>
<p>循环体内声明的变量其适用范围是从它声明到循环体结束。</p>
<p><strong>所以在for里面int i可以省内存</strong></p>
<p>命令行参数：如果希望运行一个程序的时候再传递给它消息，就要靠命令行参数给main函数实现。</p>
<p>构造方法：当一个对象被创建的时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值（可以有参数列表）</p>
<p>通常用构造方法给一个类的实例变量赋初值，或者执行其他步骤来创建一个完整对象。</p>
<p>不定义也有默认构造方法，它把所有成员初始化为0</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>typeName… parameterName</p>
<p>在方法声明中，在指定参数类型后加一个省略号(…)。</p>
<p><strong>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通参数必须在它之前声明。</strong></p>
<p>finalize()方法：</p>
<p>类似于析构函数，它在对象呗垃圾收集器析构（回收）之前被调用，这个方法叫做finalize()，它用来清除回收对象。</p>
<p>例如，可以使用finalize来确保一个对象打开的文件夹被关闭了。</p>
<p>在finalize()方法里，用户需要制定对象被销毁时要执行的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//source code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字protected是一个限定符，它确保finalize方法不会被该类外的代码调用</p>
<p><strong>Java的垃圾回收可以由JVM自动完成，如果选择手动回收垃圾，就可以用上面的方法</strong></p>
<p>System.gc()：显式调用Java垃圾收集器</p>
<h3 id="Java流-Stream-、文件-File-和IO"><a href="#Java流-Stream-、文件-File-和IO" class="headerlink" title="Java流(Stream)、文件(File)和IO"></a>Java流(Stream)、文件(File)和IO</h3><p>Java.io包几乎包含了所有操作输入、输出需要的类。流类代表了输入源和输出目标</p>
<p>Java.io包中的流支持很多格式，比如：基本类型、对象、本地化字符集等</p>
<p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据</p>
<p>Java为I/O提供了强大的灵活的支持，使得其广泛应用于文件IO和网络编程中</p>
<p>读取控制台输入：</p>
<p>Java控制台输入由System.in完成</p>
<p>获得一个绑定到控制台的字符流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br></pre></td></tr></table></figure>
<p>BufferedReader对象创建后，可以用read()方法从控制台读取一个字符，或者用readLine()方法读取一个字符串</p>
<p>每次调用read方法，它从输入流读取一个字符并把该字符作为整数值返回。流结束的时候返回-1。</p>
<p>从控制台读取字符串：</p>
<p>从标准输入读取一个字符串需要使用BufferedReader的readLine方法</p>
<p>它的一般格式是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>JDK 5以后的版本也可以使用Java Scanner类来获取控制台输入，也是更简单的方法</p>
<p>控制台输出;</p>
<p>print和println：这些方法都由类PrintStream定义，System.out是该类对象的一个引用</p>
<p>PrintStream实现write的最简单格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> byteval)</span></span></span><br></pre></td></tr></table></figure>
<p>下面演示使用write输出字符”A”和换行符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        b = <span class="string">'A'</span>;</span><br><span class="line">        System.out.write(b);</span><br><span class="line">        System.out.write(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意write方法不经常使用，因为print和println方法用起来更方便</p>
<p>读写文件：</p>
<p>流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据</p>
<p>文件输入输出流：</p>
<p>FileInputStream:</p>
<p>该流用于从文件读取数据，它的对象可以用关键字new来创建</p>
<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/java/hello"</span>);</span><br></pre></td></tr></table></figure>
<p>也可以用一个文件对象来创建一个输入流对象来读取文件，首先要用File()方法来创建一个文件对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</span><br><span class="line"><span class="function">InputStream out new <span class="title">FileInputStream</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建文件输入流之后，就可以使用下面的方法来操作流了：</p>
<p>Close：关闭文件输入流并释放与此流有关的所有系统资源。抛出IOException异常</p>
<p>finalize：清除与该文件的连接。确保在不再引用文件输入流时调用其close方法。抛出IOException异常</p>
<p>read：从InputStream对象读取指定字节数据。返回整数值，表示下一字节数据。结尾则返回-1</p>
<p>read重载：read(byte[] r) 从输入流读取r.length长度的字节。返回读取的字节数，文件结尾则返回-1</p>
<p>available：不受阻塞地读流</p>
<p>FileOutputStream：</p>
<p>该流在打开文件进行输出前，如果目标文件不存在，那么该流会创建该文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/hava/hello"</span>);</span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</span><br><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</span><br></pre></td></tr></table></figure>
<p>流操作：</p>
<p>Close：关闭此文件输出流并释放与此流有关的所有系统资源。抛出IOException异常</p>
<p>finalize：清除与该文件的连接，确保不再引用文件输入流时调用其close方法。抛出IOException异常</p>
<p>write：把指定字节写到输出流中</p>
<p>write(byte[] w)：重载，把指定数组中w.length长度的字节写到OutputStream中</p>
<p>在读写的时候注意一下数据编码即可，不要出现乱码</p>
<p>创建目录：</p>
<p>File类中有两个方法创建文件夹：</p>
<ul>
<li>mkdir()方法创建一个文件夹，成功则返回true，失败则返回false。</li>
<li>mkdirs()方法创建一个文件夹和它的所有父文件夹</li>
</ul>
<p>读取目录：</p>
<p>创建一个File对象并且如果它是一个目录，那么调用isDirectory方法会返回true</p>
<p>可以调用该对象上的list方法，来提取它包含的文件和文件夹列表</p>
<p>删除目录：</p>
<p>可以使用java.io.File.delete方法</p>
<p>需要保证该目录下没有其他文件才能正确删除，否则删除失败</p>
<p>可以用上面的这些类和方法来实现展示目录结构、递归删除目录的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级展开目录:/tmp</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span></span>&#123;</span><br><span class="line">	<span class="comment">//data</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String dirname = <span class="string">"/tmp"</span>;</span><br><span class="line">		File f1 = <span class="keyword">new</span> File(dirname);</span><br><span class="line">		<span class="keyword">if</span>(f1.isDirectory())&#123;</span><br><span class="line">			System.out.println(<span class="string">"Directory: "</span> + dirname);</span><br><span class="line">			String[] s1 = f1.list();</span><br><span class="line">			<span class="keyword">for</span>(String s:s1)&#123;</span><br><span class="line">				File f = <span class="keyword">new</span> File(dirname + <span class="string">"/"</span> + s);</span><br><span class="line">				<span class="keyword">if</span>(f.isDirectory())</span><br><span class="line">					System.out.println(s + <span class="string">" is a directory!"</span>);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					System.out.println(s + <span class="string">" is a file!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(dirname + <span class="string">" is not a directory!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java-Scanner类"><a href="#Java-Scanner类" class="headerlink" title="Java Scanner类"></a>Java Scanner类</h3><p>java.util.Scanner是Java5之后出现的新特性，可以直接通过Scanner类来获取用户的输入，而不用前面那些复杂的IO类（前面那些IO类主要是为了了解和学习）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>
<p>Scanner类的next和nextLine方法可以获取输入字符串，在读取之前需要使用hasNext和hasNextLine来判断是否还有输入的数据</p>
<p>next方法的核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(scan.hasNext())&#123;</span><br><span class="line">    System str1 = scan.next();</span><br><span class="line">    System.out.println(<span class="string">"输入的数据为: "</span> + str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nextLine方法的核心代码基本类似</p>
<p>next和nextLine的区别：</p>
<p>next():</p>
<ul>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>对输入有效字符之前遇到的空白，next方法会自动将其去掉</li>
<li>只有输入有效字符后才能将后面输入的空白作为分隔符或者结束符</li>
<li>next不能得到带有空格的字符串</li>
</ul>
<p>nextLine():</p>
<ul>
<li>以Enter为结束符，也就是说nextLine方法返回的是输入回车之前的所有字符</li>
<li>可以获得空白</li>
</ul>
<p>如果要读入int或float类型的数据，在Scanner类中也有对应支持，输入之前可以用hasNextXxx()方法检测数据类型，判断用户的输入char是否可以转换为小数或者整数格式</p>
<h3 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h3><p>异常指的是程序中的一些错误，并不是所有错误都是异常，错误有时候是可以避免的。</p>
<p>异常引发的原因有多种，通常包含：</p>
<ul>
<li>用户输入了非法数据</li>
<li>要打开的文件不存在</li>
<li>网络通信时连接中断，或者JVM内存溢出</li>
</ul>
<p>程序员需要掌握三种类型异常：</p>
<ul>
<li>检查性异常：用户错误或问题引起的异常，是程序员无法预见的，比如打开一个不存在的文件</li>
<li>运行时异常：运行异常是可能被程序员避免的异常。运行时异常可以在编译时被忽略</li>
<li>错误：错误不是异常，而是脱离程序员控制的问题。比如当栈溢出时，一个错误就发生了，它们在编译时是检查不到的。</li>
</ul>
<p>Exception类：</p>
<p>所有异常都是从java.lang.Exception类继承的子类</p>
<p>捕获异常可以用try catch代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)&#123;</span><br><span class="line">    <span class="comment">//catch块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多重捕获：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName1)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName2)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当try中的保护代码块发生一个异常时，try后面的catch块就会检查是不是要捕获的异常，如果异常发生在catch块，异常会传递到该catch块</p>
<p>throws/throw关键字：</p>
<p>如果一个方法没有捕获到一个检查性异常，那么该方法使用throws关键字来声明异常，然后在方法实现体里面用throw抛出异常</p>
<p>finally关键字用在创建try代码块后面执行的代码块，无论是否发生异常，finally代码块中的代码总是被执行，在finally代码块中，可以运行清理类型等收尾善后性质的语句。格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他关于异常没有什么好说的，日常写很少用到，用到再查就可以了</p>
<h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h3><p>允许创建分等级层次的类</p>
<p>类的继承格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承用来解决代码重复的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;		<span class="comment">//动物的名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;		<span class="comment">//动物身份标签</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String myName, <span class="keyword">int</span> myid)</span></span>&#123;</span><br><span class="line">        name = myName;</span><br><span class="line">        id = myid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"正在吃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"正在睡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大家好！我是"</span> + id + <span class="string">"号"</span> + name + <span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个animal类可以作为其他动物类的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//企鹅类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Penguin</span><span class="params">(String myName, <span class="keyword">int</span> myid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(myName, myid);	<span class="comment">//调用父类构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老鼠类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span><span class="params">(String myName, <span class="keyword">int</span> myid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(myName, myid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承的特性：</p>
<ul>
<li>子类拥有父类非private属性，方法（）实际上子类也有父类的private属性和方法，只不过被隐藏了</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</li>
<li>子类可以用自己的方式实现父类的方法，这个称为重载</li>
<li>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是祖宗关系</li>
<li>提高了类之间的耦合性（这个是继承带来的坏处，耦合度高会造成代码间联系太过紧密，代码独立性差）</li>
</ul>
<p>继承可以用extends和implements这两个关键字来实现，且所有类都是继承于java.lang.Object，这个Object是所有类的祖宗，当一个类没有继承关键字，则默认继承Object，这个特性在C++里面是没有的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extends</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(Stirng myName, String myid)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化属性值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>implements关键字主要用来实现接口，可以同时继承多个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>super和this关键字：</p>
<p>super关键字可以通过这个来实现对父类成员的访问，用来引用当前对象的父类</p>
<p>this关键字：指向自己的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal : eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//overload</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> eat&#123;&#125;&#123;</span><br><span class="line">        System.out.println(<span class="string">"dog : eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eat();		<span class="comment">//this自调用</span></span><br><span class="line">        <span class="keyword">super</span>.eat();	<span class="comment">//调用父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        a.eat();		<span class="comment">//父类吃</span></span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        d.eatTest();	<span class="comment">//调用子类吃和父类吃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>final关键字：</p>
<p>可以把类定义为不能继承的，即是最终类；或者用于修饰方法，表示该方法不能被子类重写，主要用作保护</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;&#125;</span><br><span class="line">修饰符(<span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">default</span>/<span class="keyword">protected</span>) <span class="keyword">final</span> 返回值类型 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造器：</p>
<p>子类不继承父类的构造器，只是调用。<strong>如果父类的构造器带有参数，必须在子类的构造器中显式通过super关键字调用父类的构造器并给出参数。</strong></p>
<p>如果父类是默认构造器，那么在子类构造器中可以不用管父类构造</p>
<h3 id="Java重写-Override-与重载-Overload"><a href="#Java重写-Override-与重载-Overload" class="headerlink" title="Java重写(Override)与重载(Overload)"></a>Java重写(Override)与重载(Overload)</h3><p>重写(Override)：</p>
<p>重写是子类对父类允许访问的方法的实现过程进行重新编写，返回值和形参都不变。重写的好处是子类可以个性化定制属于自己的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();	<span class="comment">//Animal对象</span></span><br><span class="line">        Animal b = <span class="keyword">new</span> Dog();	<span class="comment">//Dog对象</span></span><br><span class="line">        </span><br><span class="line">        a.move(); 	<span class="comment">//执行Animal类的方法</span></span><br><span class="line">        </span><br><span class="line">        b.move();	<span class="comment">//执行Dog类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的重写规则：</p>
<ul>
<li>参数列表必须完全和被重写的方法相同</li>
<li>返回类型必须完全与被重写的方法的返回值类型相同</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。一般都是一样的权限，这一点倒是很少会注意到，既然有这么一条就写着吧</li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为final的方法不能被重写，因为final是保护方法和类的</li>
<li>声明为static的方法不能被重写，因为static的是属于类的</li>
<li>子类和父类在同一个包中，则子类可以重写父类的所有方法，除了声明为private和final的方法。private的话子类也不能访问，final本身提供了保护</li>
<li>子类和父类不在同一个包中，则相比上一条，子类不能重写父类的friendly方法了，因为friendly表示同包访问权限</li>
<li>构造方法不能重写</li>
<li>如果不能继承，就不重写</li>
</ul>
<p>重载(Overload)：</p>
<p>重载是在同一个类中，方法名字相同而参数不同，返回值类型可以相同可以不同</p>
<p>每个重载的方法（或构造函数）都必须有一个独一无二的参数型列表</p>
<p>最常见的重载是构造函数的重载</p>
<p>重载规则:</p>
<ul>
<li>被重载的方法必须改变参数列表（参数个数或类型不同）</li>
<li>被重载的方法可以改变返回值类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>方法可以在同一个类中或者在一个子类中被重载</li>
<li>无法以返回值作为重载函数的区分标准</li>
</ul>
<p>方法的重写和重载是Java多态性的不同表现</p>
<h3 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力</p>
<p>多态是一个接口，使用不同的实例而执行不同操作</p>
<p>多态的优点：</p>
<ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<p>多态存在的三个必要条件：</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
<p>虚方法子类可以重写父类的方法，当子类调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法，被重写的方法是可以动态绑定的，如果像调用父类中被重写的方法，则必须使用关键字super</p>
<p>多态的实现方式：</p>
<ul>
<li>重写overwtire</li>
<li>接口interface</li>
<li>抽象类和抽象方法</li>
</ul>
<h3 id="Java抽象类"><a href="#Java抽象类" class="headerlink" title="Java抽象类"></a>Java抽象类</h3><p>在面向对象中，所有的对象都是通过类来描绘的，但不是所有类都是用来描绘对象的，如果一个类没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量，成员方法和构造方法的访问方式和普通类一样</p>
<p>抽象类不能实例化对象，所以抽象类必须被继承，才能使用</p>
<p>通过abstract来定义抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, String address, <span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructing an Employee"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Employee computePay"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mailing a check to "</span> + <span class="keyword">this</span>.name + <span class="string">" "</span> + <span class="keyword">this</span>.address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" "</span> + address + <span class="string">" "</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String newAddress)</span></span>&#123;</span><br><span class="line">        address = newAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法：</p>
<p>如果该方法的具体实现可以由它的子类确定，那么可以在父类中声明该方法为抽象方法</p>
<p>Abstract关键字可以用来声明抽象方法，抽象方法只包含一个方法名，没有方法体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。实现后才能实例化对象</p>
<h3 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h3><p>Encapsulation是一种将抽象是函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>封装的优点</p>
<ul>
<li>良好的封装能减少耦合</li>
<li>类内部的结构可以自由修改</li>
<li>可以对成员变量进行更精确的控制</li>
<li>隐藏信息，实现细节</li>
</ul>
<p>实现封装的步骤：</p>
<p>修改属性的可见性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将name和age属性设置为私有，只能本类才能访问，其他类访问不了，这样就实现了对信息的隐藏</p>
<h3 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h3><p>Interface，在Java语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个雷通过继承接口的方式，从而来继承接口的抽象方法。接口不是类，编写接口的方式和类很相似，但它们属于不同概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内描述的所有方法，否则就必须声明为抽象类。另外，Java中接口类型可用来声明一个变量，他们可以成为一个空指针，或者绑定一个以此接口实现的对象。</p>
<p>接口与类的相似点：</p>
<ul>
<li>一个接口可以有多个方法</li>
<li>接口文件保存在.java结尾的文件中，文件名使用接口名</li>
<li>接口的字节码文件保存在.class结尾的文件中</li>
<li>接口相应的字节码文件必须在于包名称相匹配的目录结构中</li>
</ul>
<p>接口与类的区别：</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口没有构造方法</li>
<li>接口中所有方法必须是抽象方法</li>
<li>接口中所有方法必须是抽象方法</li>
<li>接口不能包含成员变量，除了static和final变量</li>
<li>接口不是被类继承了，而是要被类实现</li>
<li>接口支持多继承</li>
</ul>
<p>接口特性：</p>
<ul>
<li>接口中每一个方法也是隐式抽象的，接口中的方法会被隐式指定为public abstract</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式指定为public static final变量</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法</li>
</ul>
<p>抽象类和接口的区别：</p>
<ul>
<li>抽象类中的方法可以有方法体，但是接口中的方法不行</li>
<li>抽象类中的成员变量可以是多种类型的，而接口类中的变量只能是public static final类型的</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li>
</ul>
<p>接口声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名称 [extends 其他的接口名]&#123;</span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    <span class="comment">//声明抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口隐式抽象，当声明一个接口的时候，不必使用abstract关键字</p>
<p>接口中每个方法也是隐式抽象的，声明不需要abstract关键字</p>
<p>接口中的方法都是公有的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口的实现：</p>
<p>当类实现接口的时候，需要实现接口中的所有方法，否则，类必须声明为抽象的类。</p>
<p>类使用implements关键字实现接口。类声明中，implements关键字放在class声明后面</p>
<p>实现一个接口的语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称</span><br></pre></td></tr></table></figure>
<p>实现接口方法的时候记住要保持一致的方法名，和相同或兼容的返回值类型</p>
<p>如果实现接口的类是抽象类，那么就没有必要实现接口的方法</p>
<p>一个接口可以继承另一个接口，和类之间的继承方式比较相似。接口的继承用extends关键字，子接口继承父接口的方法</p>
<h3 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h3><p>Package</p>
<p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间</p>
<p>包的作用：</p>
<ul>
<li>把功能相似或相关的接口组织在同一个包中，方便类的查找和使用</li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字可以相同，当调用不同包中相同类名的类时，应该加上包名加以区分</li>
<li>包限定了访问权限，拥有包访问权限的类才能访问某个包中的类</li>
</ul>
<p>Java使用包这种机制是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注释等</p>
<p>包语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg;</span><br></pre></td></tr></table></figure>
<p>包声明应该放在第一行</p>
<p>import关键字：导入包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg;</span><br></pre></td></tr></table></figure>
<h2 id="Java高级主题"><a href="#Java高级主题" class="headerlink" title="Java高级主题"></a>Java高级主题</h2><h3 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h3><ul>
<li>枚举（Enumeration）</li>
<li>位集合（BitSet）</li>
<li>向量（Vector）</li>
<li>栈（Stack）</li>
<li>字典（Dictionary）</li>
<li>哈希表（Hashtable）</li>
<li>属性（Properties）</li>
</ul>
<p>上面的数据结构是传统遗留的，在Java2中引入了一种新的框架-集合框架（Collection）</p>
<h3 id="枚举（Enumeration）"><a href="#枚举（Enumeration）" class="headerlink" title="枚举（Enumeration）"></a>枚举（Enumeration）</h3><p>枚举接口虽然本身不属于任何数据结构，但它在其他数据勾结的范畴里应用很广。枚举接口定义了一种从数据结构取回连续元素的方式。</p>
<p>枚举定义了一个叫nextElement的方法，该方法用来得到一个包含多个元素的数据结构的下一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationTester</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      Enumeration&lt;String&gt; days;</span><br><span class="line">      Vector&lt;String&gt; dayNames = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">      dayNames.add(<span class="string">"Sunday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Monday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Tuesday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Wednesday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Thursday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Friday"</span>);</span><br><span class="line">      dayNames.add(<span class="string">"Saturday"</span>);</span><br><span class="line">      days = dayNames.elements();</span><br><span class="line">      <span class="keyword">while</span> (days.hasMoreElements())&#123;</span><br><span class="line">         System.out.println(days.nextElement()); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位集合（BitSet）"><a href="#位集合（BitSet）" class="headerlink" title="位集合（BitSet）"></a>位集合（BitSet）</h3><p>位集合实现了一组可以单独设置和清除的位或标志</p>
<p>该类在处理一组布尔值的时候非常有用</p>
<h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><p>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态变化。</p>
<p>和数组一样，Vector对象的元素也能通过索引访问。</p>
<p>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态变化。</p>
<p>Vector类实现了一个动态数组，和ArrayList类似，但是两者是不同的：</p>
<ul>
<li>Vector是同步访问的</li>
<li>Vector包含了许多传统方法，这些方法不属于集合框架</li>
</ul>
<p>Vector主要用在事先不知道数组的大小，或者只需要一个可以改变大小的数组的情况</p>
<p>Vector类支持四种构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector();</span><br><span class="line">Vector(<span class="keyword">int</span> size);</span><br><span class="line">Vector(<span class="keyword">int</span> size, <span class="keyword">int</span> incr);</span><br><span class="line">Vector(Collection c);</span><br></pre></td></tr></table></figure>
<p>除了从父类继承的方法外Vector还定义了以下方法：</p>
<p>add：在向量的指定位置插入指定的元素，add(int index, Object element)</p>
<p>add：提供了末尾添加的重载方法，add(Object element)</p>
<p>capacity：返回此向量当前的容量</p>
<p>clear：从向量中移除所有元素</p>
<p>clone：返回向量的一个副本</p>
<p>contains：如果此向量包含指定的元素，则返回true</p>
<p>equals：比较指定对象与此对象的相等性</p>
<p>get：返回向量中指定位置的元素，参数为索引值</p>
<p>indexOf：返回此向量中第一次出现的指定元素的索引，从index处正向搜索，如果未找到该元素，则返回-1</p>
<p>lastIndexOf：返回向量中最后一次出现指定元素的索引，如果未找到则返回-1</p>
<p>isEmpty：判断是否为空</p>
<p>firstElement：返回向量的第一个组件</p>
<p>lastElement：返回向量的最后一个组件</p>
<p>remove：移除指定位置的元素</p>
<p>size：和capacity不同，返回的是现在向量中的组件数</p>
<p>toString：返回此向量的字符串表示形式，其中包含每个元素的String表示形式</p>
<p>elements：返回此向量组件的枚举，可以直接赋值给枚举变量</p>
<p>remove:两类重载，接受index参数或者Object参数，移除指定位置的元素或者移除指定元素的第一个匹配项</p>
<p>removeAll：移除所有指定元素，接受Collection参数</p>
<p>toArray：返回一个数组</p>
<p>toString：返回一个字符串</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构</p>
<p>可以把栈理解为垂直分布的栈，当添加一个元素时，就将新元素放在其他元素的顶部</p>
<p>当从栈中取出元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</p>
<p>是Vector一个子类，Stack定义了默认构造用来创建空栈</p>
<ul>
<li>empty:测试堆栈是否为空</li>
<li>peek:查看栈顶对象并不移除</li>
<li>pop:移除栈顶对象并返回</li>
<li>push:把项压入堆栈顶部</li>
<li>search:返回对象在栈中的位置，以1位基数</li>
</ul>
<h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><p>字典（Dictionary）类是一个抽象类，它定义了键值映射到值的数据结构</p>
<p>当想要通过特定的键而不是整数索引来访问数据的时候，应该使用Dictionary</p>
<p>由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现</p>
<p>和Map类相似。</p>
<ul>
<li>element:返回值的枚举</li>
<li>get:返回指定键对应的值</li>
<li>isEmpty:测试字典是否为空</li>
<li>keys:返回键的枚举</li>
<li>remove:接受key参数，从字典中移除指定key</li>
<li>put:put(Object key, Object value),将指定key映射到该字典中指定的value</li>
<li>size:返回条目的数量</li>
</ul>
<p>Dictionary类已经过时了，在实际的开发中，常常使用Map</p>
<h3 id="哈希表（Hashtable）"><a href="#哈希表（Hashtable）" class="headerlink" title="哈希表（Hashtable）"></a>哈希表（Hashtable）</h3><p>Hashtable类提供了一种在用户键结构的基础上来组织数据的手段</p>
<p>Hashtable现已经集成到集合框架中。和HashMap类似，但是支持同步</p>
<p>构造方法：</p>
<ul>
<li>Hashable()</li>
<li>Hashtable(int size) //创建指定大小的哈希表</li>
<li>Hashtable(int size, float fillRatio) //创建指定大小的哈希表，并根据fillRate填充</li>
<li>Hashtable(Map m) //以m中元素为初始化元素的哈希表</li>
</ul>
<p>Hashtable除了实现Map接口中定义的方法之外，还自定义了其他的方法</p>
<ul>
<li>clear: 清空哈希表，使其不包含任何键值</li>
<li>contains: 给的参数是值，测试是否存在对应的键</li>
<li>isEmpty: 判断哈希表是否为空</li>
<li>size: 返回键的数量</li>
<li>toString: 返回Hashtable的字符串形式</li>
</ul>
<h3 id="属性（Properties）"><a href="#属性（Properties）" class="headerlink" title="属性（Properties）"></a>属性（Properties）</h3><p>Properties继承于Hashtable.Properties类表示一个持久的属性集，水星列表中每个键及其对应值都是一个字符串</p>
<p>Properties类被许多Java类使用。</p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>Java的集合框架主要包括两种类型的容器，一种是集合(Collection)，存储一个元素集合，另一种是图(Map),存储键值映射。Collection接口有三种子类型：List, Set和Queue，再下面是抽象类，再下面是具体实现类，常用的有ArrayList, LinkedList, HashSet, LinkedHashset。集合框架提供了一套性能优良，使用方便的接口和类。Java集合框架位于java.util包里，所以使用集合框架的时候需要导包。</p>
<h3 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h3><ul>
<li><p>Collection接口：是最基本的集合接口，一个Collection代表一组Object，存储一组不唯一，无序的对象</p>
</li>
<li><p>List接口：是一个有序的Collection，支持0索引。存储不唯一，有序的对象</p>
</li>
<li><p>Set接口：与Collection一样，只是不允许重复</p>
</li>
<li><p>SortedSet接口：继承于Set保存有序集合</p>
</li>
<li><p>Map接口：存储键值对，提供key到value的映射</p>
</li>
<li><p>SortedMap：继承于Map，使Map保证升序排列</p>
</li>
</ul>
<p>Set和List相比，Set无序不重复，List有序可以重复</p>
<p>Set访问效率低，删除和插入效率高</p>
<p>List和数组类似，可以动态增长。其实现类有ArrayList，LinkedList，Vector</p>
<p>使用迭代器进行遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; ite = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">	System.out.println(ite.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把链表变成相关容器再遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String strArray = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">list.toArray(strArray);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++)&#123;</span><br><span class="line">	System.out.println(strArray[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><p>generics。和C++泛型差不多，具体要用可以再查，平时练习是用不到的。</p>
<h3 id="泛型方法："><a href="#泛型方法：" class="headerlink" title="泛型方法："></a>泛型方法：</h3><p>方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型。编译器适当地处理每个方法的调用</p>
<h3 id="泛型类："><a href="#泛型类：" class="headerlink" title="泛型类："></a>泛型类：</h3><p>在类名后面加上类型参数声明部分</p>
<h3 id="类型通配符："><a href="#类型通配符：" class="headerlink" title="类型通配符："></a>类型通配符：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>差不多就完结了，后面一些比如序列化，网络编程之类的，平常也用不到，只有特定的开发场景中才可能会用到。另外Java Mooc笔记没有上传，因为没有全部看完。</p>

      
    </div>

    

    
    
    

    <div>
    
    <div>

    <div style="text-align:center;color: #ccc;font-size:14px;">-------------End of the article <i class="fa fa-paw"></i> Thanks for reading!-------------</div>

</div>
    
    </div>

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Programming/" rel="tag"><i class="fa fa-tag"></i> Programming</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/24/正则表达式/" rel="next" title="正则表达式">
                <i class="fa fa-chevron-left"></i> 正则表达式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/24/Mac删除launchpad中无法正常删除的图标/" rel="prev" title="Mac删除launchpad中无法正常删除的图标">
                Mac删除launchpad中无法正常删除的图标 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Qingliu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Aden-Q" title="GitHub &rarr; https://github.com/Aden-Q" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:qian0102@umn.edu" title="E-Mail &rarr; mailto:qian0102@umn.edu" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.facebook.com/zecheng.qian.7" title="FB Page &rarr; https://www.facebook.com/zecheng.qian.7" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i>FB Page</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础语法"><span class="nav-number">1.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源文件声明规则"><span class="nav-number">1.1.</span> <span class="nav-text">源文件声明规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java数据类型"><span class="nav-number">1.2.</span> <span class="nav-text">Java数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java变量类型"><span class="nav-number">1.3.</span> <span class="nav-text">Java变量类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java局部变量"><span class="nav-number">1.3.1.</span> <span class="nav-text">Java局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java实例变量"><span class="nav-number">1.3.2.</span> <span class="nav-text">Java实例变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java类变量"><span class="nav-number">1.3.3.</span> <span class="nav-text">Java类变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java修饰符"><span class="nav-number">1.4.</span> <span class="nav-text">Java修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java运算符"><span class="nav-number">1.5.</span> <span class="nav-text">Java运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环控制"><span class="nav-number">1.6.</span> <span class="nav-text">循环控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包裹类型：封包和解包"><span class="nav-number">1.7.</span> <span class="nav-text">包裹类型：封包和解包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-String类"><span class="nav-number">1.8.</span> <span class="nav-text">Java String类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer和StringBuilder类"><span class="nav-number">1.9.</span> <span class="nav-text">StringBuffer和StringBuilder类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java数组"><span class="nav-number">1.10.</span> <span class="nav-text">Java数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Arrays类"><span class="nav-number">1.10.1.</span> <span class="nav-text">Arrays类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期和时间"><span class="nav-number">1.11.</span> <span class="nav-text">日期和时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">1.12.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java方法"><span class="nav-number">1.13.</span> <span class="nav-text">Java方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数"><span class="nav-number">1.14.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java流-Stream-、文件-File-和IO"><span class="nav-number">1.15.</span> <span class="nav-text">Java流(Stream)、文件(File)和IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Scanner类"><span class="nav-number">1.16.</span> <span class="nav-text">Java Scanner类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-异常处理"><span class="nav-number">1.17.</span> <span class="nav-text">Java 异常处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象"><span class="nav-number">2.</span> <span class="nav-text">Java面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java继承"><span class="nav-number">2.1.</span> <span class="nav-text">Java继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java重写-Override-与重载-Overload"><span class="nav-number">2.2.</span> <span class="nav-text">Java重写(Override)与重载(Overload)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java多态"><span class="nav-number">2.3.</span> <span class="nav-text">Java多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java抽象类"><span class="nav-number">2.4.</span> <span class="nav-text">Java抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java封装"><span class="nav-number">2.5.</span> <span class="nav-text">Java封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java接口"><span class="nav-number">2.6.</span> <span class="nav-text">Java接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java包"><span class="nav-number">2.7.</span> <span class="nav-text">Java包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java高级主题"><span class="nav-number">3.</span> <span class="nav-text">Java高级主题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java数据结构"><span class="nav-number">3.1.</span> <span class="nav-text">Java数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举（Enumeration）"><span class="nav-number">3.2.</span> <span class="nav-text">枚举（Enumeration）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位集合（BitSet）"><span class="nav-number">3.3.</span> <span class="nav-text">位集合（BitSet）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向量（Vector）"><span class="nav-number">3.4.</span> <span class="nav-text">向量（Vector）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈（Stack）"><span class="nav-number">3.5.</span> <span class="nav-text">栈（Stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典（Dictionary）"><span class="nav-number">3.6.</span> <span class="nav-text">字典（Dictionary）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表（Hashtable）"><span class="nav-number">3.7.</span> <span class="nav-text">哈希表（Hashtable）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性（Properties）"><span class="nav-number">3.8.</span> <span class="nav-text">属性（Properties）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架"><span class="nav-number">4.</span> <span class="nav-text">集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合接口"><span class="nav-number">4.1.</span> <span class="nav-text">集合接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java泛型"><span class="nav-number">5.</span> <span class="nav-text">Java泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型方法："><span class="nav-number">5.1.</span> <span class="nav-text">泛型方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型类："><span class="nav-number">5.2.</span> <span class="nav-text">泛型类：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型通配符："><span class="nav-number">5.3.</span> <span class="nav-text">类型通配符：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qingliu</span>

  

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    Number of visitors: <span id="busuanzi_value_site_uv"></span>
</span>
</div>


<!--
<span class="post-meta-divider">|</span>



  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.5.0</div>



-->

<span class="post-meta-divider">|</span>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">Total 63.6k words</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  



  
    
      
  
  <script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "TTkRYLVAOPvuxQuV5scOHl9U-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "TTkRYLVAOPvuxQuV5scOHl9U-gzGzoHsz",
                'X-LC-Key': "fCRGgKjo3tYIfbW3ygKrNCRN",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

  


</body>
</html>
